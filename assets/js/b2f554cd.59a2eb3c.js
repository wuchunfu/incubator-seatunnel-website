"use strict";(self.webpackChunkseatunnel_website=self.webpackChunkseatunnel_website||[]).push([[301],{30010:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"Upcoming API Connector Development Analysis","metadata":{"permalink":"/blog/Upcoming API Connector Development Analysis","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2022-06-23-New_Connector.md","source":"@site/blog/2022-06-23-New_Connector.md","title":"Upcoming API Connector Development Analysis","description":"After days of community development, the preliminary development of the new Connector API of SeaTunnel is completed. The next step is to adapt this new connector. In order to aid the developers to use this connector, this article provides guide to develop a new API.","date":"2022-06-23T00:00:00.000Z","formattedDate":"June 23, 2022","tags":[{"label":"Meetup","permalink":"/blog/tags/meetup"}],"readingTime":3.28,"truncated":false,"authors":[],"frontMatter":{"slug":"Upcoming API Connector Development Analysis","title":"Upcoming API Connector Development Analysis","tags":["Meetup"]},"nextItem":{"title":"How dose Apache SeaTunnel refactor the API to decouple with the computing engine","permalink":"/blog/How dose Apache SeaTunnel refactor the API to decouple with the computing engine"}},"content":"After days of community development, the preliminary development of the new Connector API of SeaTunnel is completed. The next step is to adapt this new connector. In order to aid the developers to use this connector, this article provides guide to develop a new API.\\n\\n## Priliminary Setup\\n- Environment configuration: JDK8 and Scala2.11 are recommended.\\n- As before, we need to download the latest code locally through git and import it into the IDE, project address: https://github.com/apache/incubator-seatunnel . At the same time, switch the branch to api-draft, and currently use this branch to develop the new version of the API and the corresponding Connector. The project structure is as follows:\\n\\n  ![Project Structure](/image/20220623/en/0.png)\\n\\n## Prerequisites\\n- At present, in order to distinguish different Connectors, we put the connectors that support\\n    - Flink/Spark under the ``seatunnel-connectors/seatunnel-connectors-flink(spark)`` module.\\n    - New version of the Connector is placed under the ``seatunnel-connectors/seatunnel-connectors-seatunnel`` module.\\n\\n  As we can see from the above figure, we have implemented Fake, Console, Kafka Connector, and Clickhouse Connector is also being implemented.\\n- At present, the data type we support is SeaTunnelRow, so no matter the type of data generated by the Source or the type of data consumed by the Sink, it should be SeaTunnelRow.\\n\\n# Development of Connector\\nTaking Fake Connector as an example, let\'s introduce how to implement a new Connector:\\n\\n- Create a corresponding module with a path under ``seatunnel-connectors-seatunnel``, which is at the same level as other new connectors.\\n- Modify the ``seatunnel-connectors-seatunnel/pom.xml`` file, add a new module to modules, modify ``seatunnel-connectors-seatunnel/seatunnel-connector-seatunnel-fake/pom.xml``, add seatunnel-api dependencies, and correct parent Quote. The resulting style is as follows:\\n\\n  ![Style](/image/20220623/en/1.png)\\n\\n- The next step is to create the corresponding package and related classes, create FakeSource, and need to inherit SeaTunnel Source.\\n\\n    - Note : The Source of SeaTunnel adopts the design of stream and batch integration. The Source of SeaTunnel determines whether current Source is a stream or batch through attribute getBoundedness.\\n\\n  So you can specify a Source as a stream or batch by dynamic configuration (refer to the default method). The configuration defined by the user in the configuration file can be obtained through the prepare method to realize the customized configuration.\\n\\n  Then create FakeSourceReader, FakeSource SplitEnumerator, and FakeSourceSplit to inherit the corresponding abstract classes (which can be found in the corresponding classes). As long as we implement the corresponding methods of these classes, then our SeaTunnel Source Connector is basically completed.\\n- Next, just follow the existing example to write the corresponding code. The most important one is the FakeSource Reader, which defines how we obtain data from the outside, which is the most critical part of the Source Connector. Every time a piece of data is generated, we need to place it in the collector as shown:\\n\\n  ![Source](/image/20220623/en/2.png)\\n- After the code development is complete, we need to configure the configuration file ``plugin-mapping.properties`` located under ``seatunnel-connectors/modules``. Adding a seatunnel\\n  ``.source.FakeSource = seatunnel-connector-fake``\\n  means that SeaTunnel can find the jar package corresponding to the project by looking for a Source named FakeSource. This allows the Connector to be used in the normal configuration file.\\n- For a detailed description of writing Source and Sink and SeaTunnel API, please refer to the introduction at ``seatunnel-connectors/seatunnel-connectors-seatunnel/ README.zh.md``.\\n\\n## Connector Testing\\n- For testing, we can find the ``seatunnel-flink(spark)-new-connector-example`` module in seatunnel-examples, and test it against different engines to ensure that the performance of the Connector is as consistent as possible. If you find any discrepancies, you can mark them in the document, modify the configuration file under resource, add our Connector to the configuration, and introduce ``seatunnel-flink(spark)-new-connector-example/pom.xml`` dependency, you can execute ``SeaTunnelApiExample`` to test.\\n- The default is stream processing mode, and the execution mode is switched to batch mode by modifying ``job.mode=BATCH`` in the environment of the configuration file.\\n\\n## Submit PR\\nWhen our Connector is ready, we can submit PR to github. After reviewing by other partners, our contributed Connector will become part of SeaTunnel!"},{"id":"How dose Apache SeaTunnel refactor the API to decouple with the computing engine","metadata":{"permalink":"/blog/How dose Apache SeaTunnel refactor the API to decouple with the computing engine","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2022-05-31-engine.md","source":"@site/blog/2022-05-31-engine.md","title":"How dose Apache SeaTunnel refactor the API to decouple with the computing engine","description":"Translator | Critina","date":"2022-05-31T00:00:00.000Z","formattedDate":"May 31, 2022","tags":[{"label":"Meetup","permalink":"/blog/tags/meetup"}],"readingTime":11.1,"truncated":false,"authors":[],"frontMatter":{"slug":"How dose Apache SeaTunnel refactor the API to decouple with the computing engine","title":"How dose Apache SeaTunnel refactor the API to decouple with the computing engine","tags":["Meetup"]},"prevItem":{"title":"Upcoming API Connector Development Analysis","permalink":"/blog/Upcoming API Connector Development Analysis"},"nextItem":{"title":"How to synchronize tens of billions of data based on SeaTunnel\'s ClickHouse","permalink":"/blog/How to synchronize tens of billions of data based on SeaTunnel\'s ClickHouse"}},"content":"![](/image/20220531/en/0.jpg)\\n\\nTranslator | Critina\\n\\nIn the May joint Meetup between Apache SeaTunnel and Apache Inlong, Li Zongwen, a senior engineer at WhaleOps, shared his experiences about finding and refactoring of the the four major problems with Apache SeaTunnel (Incubating).i.e. the connectors of SeaTunnel have to be implemented many times,the inconsistent parameters, SeaTunnel is not supportive of multiple versions of the engine, and it\u2019s difficult to upgrade the engine. In order to solve these problems, Li Zongwen aimed to decouple Apache SeaTunnel (Incubating) from thw computing engines, and re-factor the Source and Sink apis to improve the development experience.\\n\\nThis speech mainly consists of five parts.The first part is about Apache SeaTunnel (Incubator) refactoring background and motivation. The second part introduces Apache SeaTunnel (Incubating) Target for refactoring.The third part discusses Apache SeaTunnel (Incubating) overall design for refactoring. The last two parts is about Apache SeaTunnel (Incubating) Source API design and Apache SeaTunnel (Incubating) Sink API design.\\n\\n## 01 Background and motivation for refactoring\\n\\nThose of you who have used Apache SeaTunnel (Incubator) or developers should know that Apache SeaTunnel (Incubator) is now fully coupled with the engine, which is entirely based on Spark or Flink, and so are the configuration file parameters. From the perspective of contributors and users, we can find they face some problems.\\n\\nIn the view of the contributors, repeated implementing connector is meaningless and it is unable for potential contributors to contribute to the community due to inconsistent engine versions.\\n\\nAt present, many companies use Lambda architecture, Spark is used for offline operations and Flink is used for real-time operations. In the view of the users, it can be found that Spark may have the Connector of SeaTunnel, but Flink does not, and the parameters of the two engines for the Connector of the same storage engine are not unified, thus resulting a high cost of and deviating from its original intention of being easy to use. And some users question that Flink version 1.14 is not supported nowadays. While with the current SeaTunnel architecture, we must discard the previous version in order to support Flink version 1.14, which will bring great trouble for early version users.\\n\\nAs a result, it was difficult for us to either upgrade engine or support more versions.\\n\\nIn addition, Spark and Flink both adopt the Checkpoint fault-tolerant mechanism implemented by Chandy-Lamport algorithm and internally unify DataSet and DataStream. On this premise, we believe decoupling is feasible.\\n\\n## 02 Apache SeaTunnel (Incubating) decouples with computing engine\\n\\n\\nTherefore, in order to solve the problems raised above, we set the following goals.\\n\\n1. Connector is only implemented once. To solve the problems that parameters are not unified and Connector is implemented for too many times, we hope to achieve a unified Source and Sink API;\\n\\n2. Multiple versions of Spark and Flink engines are supported. A translation layer above the Source and Sink API is added to support multiple versions of Spark and Flink engines.\\n\\n3. The logic for parallel shard of Source and the Sink submission should be clarified. We must provide a good API to support Connector development.\\n\\n4. The full database synchronization in real-time scenarios should be supported. This is a derivative requirement that many users have mentioned for CDC support. I once participated the Flink CDC community before and many users pointed out that in the CDC scenario, if you wanted to use the Flink CDC directly, each table would have a link and there would be thousands of links for thousands of tables when you need to synchronize the whole library, which was unacceptable for both the database and the DBA. To solve this problem, the simplest way was to introduce Canal\u3001Debezium or other components, which were used to pull incremental data to Kafka or other MQ for intermediate storage, and then we could use Flink SQL for synchronization. This actually contradicted the original idea of the Flink CDC to reduce links. However, the Flink CDC aimed only a Connector and was unable to deal with the whole link, so the proposal was not seen in the SeaTunnel community. By the chance of the reconstruction, we submitted the proposal to the SeaTunnel community.\\n\\n5. Automatic discovery and storage of meta information are realized. The users should have awful experience due to the storage engines such as Kafka lacking of record of the data structure, when we need to read structured data, the user must define the topic of structured data types before read one topic at a time . We hope once the configuration is completed, there is no need to do any redundant work again.\\n\\nSome people may wonder why we don\u2019t use Apache Beam directly. That is because Beam sources are divided into BOUNDED and UNBOUNDED sources, which means it needs to be implemented twice. Moreover, some features of Source and Sink are not supported, which will be mentioned later.\\n\\n## 03 Apache SeaTunnel(Incubating) overall design for refactoring\\n\\n![](/image/20220531/en/1.jpg)\\n\\nThe Apache SeaTunnel(Incubating) API architecture is described in the picture above.\\n\\nThe Source & Sink API is one of the core APIS of data integration, which defines the logic for parallel shard of Source and the commitment of Sink to realize the Connector.\\n\\nThe Engine API includes the translation and the execution layers. The translation is used to translate Souce and Sink API of SeaTunnel into connectors that can be run inside the engine.\\n\\nThe execution defines the execution logic of Source, Transform, Sink and other operations in the engine.\\n\\nThe Table SPI is mainly used to expose the interface of Source and Sink in SPI mode, and to specify mandatory and optional parameters of Connector etc.\\n\\nThe DataType includes SeaTunnel data structure used to isolate engines and declare Table schema.\\n\\nThe Catalog is Used to obtain Table schemes and Options, etc. The Catalog Storage is used to store Table Schemes defined by unstructured engines such as Kafka.\\n\\n![](/image/20220531/en/2.jpg)\\n\\n\\nThe execution flow we assumed nowadays can be see in the above picture.\\n\\n1. Obtain task parameters from configuration files or UI.\\n\\n2. Obtain the Table Schema, Option and other information by analyzing the parameters from Catalog.\\n\\n3. Pull up the Connector of SeaTunnel in SPI mode and inject Table information.\\n\\n4. Translate the Connector from SeaTunnel into the Connector within the engine.\\n\\n5. Execute the operation logic of the engine. The multi-table distribution in the picture only exists in the synchronization of the whole database of CDC, while other connectors are single tables and do not need the distribution logic.\\n\\nIt can be seen that the hardest part of the plan is to translate Source and Sink into an internal Source and Sink in the engine.\\n\\nMany users today use Apache SeaTunnel (Incubating) not only as a data integration tool but also as a data storage tool, and use a lot of Spark and Flink SQLs. We want to preserve that SQL capability for users to upgrade seamlessly.\\n\\n\\n![](/image/20220531/en/3.jpg)\\n\\n\\nAccording to our research, the feature above shows the ideal execution logic of Source and Sink. Since SeaTunnel is incubated as WaterDrop, the terms in the figure are tended towards Spark.\\n\\nIdeally, the Source and Sink coordinators can be run on the Driver, and the Source Reader and Sink Writer will run on the Worker. In terms of the Source Coordinator, we expect it to support several features.\\n\\nThe first capability is that the slicing logic of data can be dynamically added to the Reader.\\n\\nThe second is that the coordination of Reader can be supported. Source Reader is used to read data, and then send the data to the engine, and finally to the Source Writer for data writing. Meanwhile, Writer can support the two-phase transaction submission, and the coordinator of Sink supports the aggregation submission requirements of Connector such as Iceberg.\\n\\n## 04 Source API\\n\\n\\nAfter research, we found the following features that are required by Source.\\n\\n1. Unified offline and real-time API , which supports that source is implemented only once and supports both offline and real-time API;\\n\\n2. Supportive of parallel reading. For example that Kafka generates a reader for each partition and execute in parallel.\\n\\n3. Supporting dynamic slice-adding. For example, Kafka defines a regular topic, when a new topic needs to be added due to the volume of business, the Source API allows to dynamically add the slice to the job.\\n\\n4. Supporting the work of coordinating reader, which is currently only needed in the CDC Connector. CDC is currently supported by NetFilx\u2019s DBlog parallel algorithms, which requires reader coordination between full synchronization and incremental synchronization.\\n\\n5. Supporting a single reader to process multiple tables, i.e. to allows the whole database synchronization in the real-time scenario as mentioned above.\\n\\n![](/image/20220531/en/4.jpg)\\n\\n\\nBased on the above requirements, we have created the basic API as shown in the figure above. And the code has been submitted to the API-Draft branch in the Apache SeaTunnel(Incubator) community. If you\u2019re interested, you can view the code in detail.\\n\\n### How to adapt to Spark and Flink engines\\n\\n\\nFlink and Spark unify the API of DataSet and DataStream, and they can support the first two features. Then, for the remaining three features, how do we\\n\\n- Support dynamic slice-adding\uff1f\\n- Support the work of coordinating reader\uff1f\\n- Support a single reader to process multiple tables\uff1f\\n\\nLet\'s review the design with questions.\\n\\n![](/image/20220531/en/5.jpg)\\n\\n\\nWe found that other connectors do not need coordinators, except for CDC. For those connectors that do not need coordinators, we have a Source that supports parallel execution and engine translation.\\n\\nAs shown in the figure above, there is a slice enumerator on the left, which can list which slices the source needs and show what there are. After enumerating slices in real time, each slice would be distributed to SourceReader, the real data reading module. Boundedness marker is used to differentiate offline and real-time operations. Connector can mark whether there is a stop Offset in a slice. For example, Kafka can support real-time and offline operations. The degree of parallelism can be set for the ParallelSource in the engine to support parallel reading.\\n\\n\\nAs shown in the figure above, in a scenario where a coordinator is required, Event transmission is done between the Reader and Enumerator. Enumerator coordinates events by the Event sent by the Reader. The Coordinated Source needs to ensure single parallelism at the engine level to ensure data consistency. Of course, this does not make good use of the engine\u2019s memory management mechanism, but trade-offs are necessary.\\n\\n\\n![](/image/20220531/en/6.jpg)\\n\\n\\nFor the last question, how can we support a single reader to process multiple tables? This involves the Table API layer. Once all the required tables have been read from the Catalog, some of the tables may belong to a single job and can be read by a link, and some may need to be separated, depending on how Source is implemented. Since this is a special requirement, we want to make it easier for the developers. In the Table API layer, we will provide a SupportMultipleTable interface to declare that Source supports multiple Table reads. The Source is implemented based on the corresponding deserializer of multiple tables. As for how to separate derived multi-table data, Flink will adopt Side Output mechanism, while Spark is going to use Filter or Partition mechanism.\\n\\n## 5 Sink API\\n\\nAt present, there are not many features required by Sink, but three mojor requirements are considerable according to our research.\\n\\nThe first is about idempotent writing, which requires no code and depends on whether the storage engine can support it.\\n\\nThe second is about distributed transactions. The mainstream method is two-phase commitments, such as Kafka etc.\\n\\nThe third is about the submission of aggregation. For Storage engines like Iceberg and Hoodie, we hope there is no issues triggered by small files, so we expect to aggregate these files into a single file and commit it as a whole.\\n\\nBased on these three requirements, we built three APIS: SinkWriter, SinkCommitter, and SinkAggregated Committer. SinkWriter plays a role of writing, which may or may not be idempotent. SinkCommitter supports for two-phase commitments. SinkAggregatedCommitter supports for aggregated commitments.\\n\\n![](/image/20220531/en/7.jpg)\\n\\n\\nIdeally, AggregatedCommitter runs in Driver in single or parallel, and Writer and Committer run in Worker with multiple parallels, with each parallel carrying its own pre-commit work and then send Aggregated messages to Aggregated committers.\\n\\nCurrent advanced versions of Spark and Flink all support AggregatedCommitter running on the Driver(Job Manager) and Writer and Committer running on the worker(Task Manager).\\n\\n![](/image/20220531/en/8.jpg)\\n\\n\\nHowever, for the lower versions of Flink, AggregatedCommitter cannot be supported to run in JM, so we are also carrying translation adaptation. Writer and Committer will act as pre-operators, packaged by Flink\u2019s ProcessFunction, supports concurrent pre-delivery and write, and implement two-phase commitment based on Flink\u2019s Checkpoint mechanism. This is also the current 2PC implementation of many of Flink connectors. The ProcessFunction can send messages about pre-commits to downstream Aggregated committers, which can be wrapped around operators such as SinkFunction or ProcessFunction. Of course, We need to ensure that only one single parallel will be started by the AggregatedCommitter in case of the broken of the logic of the aggregated commitment.\\n\\nThank you for watching. If you\u2019re interested in the specific implementations mentioned in my speech, you can refer to the Apache SeaTunnel (Incubating) community and check out the API-Draft branch code. Thank you again."},{"id":"How to synchronize tens of billions of data based on SeaTunnel\'s ClickHouse","metadata":{"permalink":"/blog/How to synchronize tens of billions of data based on SeaTunnel\'s ClickHouse","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2022-05-10-ClickHouse.md","source":"@site/blog/2022-05-10-ClickHouse.md","title":"How to synchronize tens of billions of data based on SeaTunnel\'s ClickHouse","description":"Author | Fan Jia, Apache SeaTunnel(Incubating) Contributor","date":"2022-05-10T00:00:00.000Z","formattedDate":"May 10, 2022","tags":[{"label":"Meetup","permalink":"/blog/tags/meetup"}],"readingTime":7.035,"truncated":false,"authors":[],"frontMatter":{"slug":"How to synchronize tens of billions of data based on SeaTunnel\'s ClickHouse","title":"How to synchronize tens of billions of data based on SeaTunnel\'s ClickHouse","tags":["Meetup"]},"prevItem":{"title":"How dose Apache SeaTunnel refactor the API to decouple with the computing engine","permalink":"/blog/How dose Apache SeaTunnel refactor the API to decouple with the computing engine"},"nextItem":{"title":"SeaTunnel Application and Refactoring at Kidswant","permalink":"/blog/SeaTunnel Application and Refactoring at Kidswant"}},"content":"![](/image/20220510/en/0.jpg)\\n\\n\\nAuthor | Fan Jia, Apache SeaTunnel(Incubating) Contributor\\nEditor | Test Engineer Feng Xiulan\\n\\nFor importing billions of batches of data, the traditional JDBC approach does not perform as well as it should in some massive data synchronization scenarios. To write data faster, Apache SeaTunnel (Incubating) has just released version 2.1.1 to provide support for ClickhouseFile-Connector to implement Bulk load data writing.\\n\\nBulk load means synchronizing large amounts of data to the target DB. SeaTunnel currently supports data synchronization to ClickHouse.\\n\\nAt the Apache SeaTunnel (Incubating) April Meetup, Apache SeaTunnel (Incubating) contributor Fan Jia shared the topic of \\"ClickHouse bulk load implementation based on SeaTunnel\\", explaining in detail the implementation principle and process of ClickHouseFile for efficient processing of large amounts of data.\\n\\nThanks to the test engineer Feng Xiulan for the article arrangement!\\n\\nThis presentation contains seven parts.\\n\\n- State of ClickHouse Sink\\n- Scenarios that ClickHouse Sink isn\'t good at \\n- Introduction to the ClickHouseFile plugin\\n- ClickHouseFile core technologies\\n- Analysis of ClickHouseFile plugin implementation\\n- Comparison of plug-in capabilities\\n- Post-optimization directions\\n\\n\\n\\n![](/image/20220510/en/0-1.png)\\n\\n\\nFan Jia,  Apache SeaTunnel (Incubating) contributor, Senior Enginee of WhaleOps.\\n\\n## 01 Status of ClickHouse Sink \\n\\nAt present, the process of synchronizing data from SeaTunnel to ClickHouse is as follows: as long as the data source is supported by SeaTunnel, the data can be extracted, converted (or not), and written directly to the ClickHouse sink connector, and then written to the ClickHouse server via JDBC. \\n\\n\\n![](/image/20220510/en/1.png)\\n\\n\\nHowever, there are some problems with writing to the ClickHouse server via traditional JDBC.\\n\\nFirstly, the tool used now is the driver provided by ClickHouse and implemented via HTTP, however, HTTP is not very efficient to implement in certain scenarios. The second is the huge amount of data, if there is duplicate data or a large amount of data written at once, it needs to generate the corresponding insert statement and send it via HTTP to the ClickHouse server-side by the traditional method, where it is parsed and executed item by item or in batches, which does not allow data compression.\\n\\nFinally, there is the problem we often encounter, i.e. too much data may lead to an OOM on the SeaTunnel side or a server-side hang due to too much data being written to the server-side too often.\\n\\nSo we thought, is there a faster way to send than HTTP? If data pre-processing or data compression could be done on the SeaTunnel side, then the network bandwidth pressure would be reduced and the transmission rate would be increased.\\n\\n## 02 Scenarios that ClickHouse Sink isn\'t good at\\n\\n1. If the HTTP transfer protocol is used, HTTP may not be able to handle it when the volume of data is too large and the batch is sending requests in micro-batches.\\n \\n2. Too many INSERT requests may put too much pressure on the server. The bandwidth can handle a large number of requests, but the server-side is not always able to carry them. The online server not only needs data inserts but more importantly, the query data can be used by other business teams. If the server cluster goes down due to too much-inserted data, it is more than worth the cost.\\n\\n## 03 ClickHouse File core technologies\\n\\nIn response to these scenarios that ClickHouse is not good at, we wondered is there a way to do data compression right on the Spark side, without increasing the resource load on the Server when writing data, and with the ability to write large amounts of data quickly? So we developed the ClickHouseFile plugin to solve the problem.\\n\\nThe key technology of the ClickHouseFile plugin is ClickHouse -local. ClickHouse-local mode allows users to perform fast processing of local files without having to deploy and configure a ClickHouse Server. C lickHouse-local uses the same core as ClickHouse Server, so it supports most features as well as the same format and table engine.\\n\\nThese two features mean that users can work directly with local files without having to do the processing on the ClickHouse Server side. Because it is the same format, the data generated by the operations we perform on the remote or SeaTunnel side is seamlessly compatible with the server-side and can be written to using ClickHouse local. ClickHouse local is the core technology for the implementation of ClickHouseFile, which allows for implementing the ClickHouse file connector.\\n\\nClickHouse local core is used in the following ways.\\n\\n\\n\\n![](/image/20220510/en/2.png)\\n\\n\\n\\nFirst line: pass the data to the test_table table of the ClickHouse-local program via the Linux pipeline.\\n\\nLines two to five: create a result_table for receiving data.\\n\\nThe sixth line: pass data from test_table to the result_table.\\n\\nLine 7: Define the disk path for data processing.\\n\\nBy calling the Clickhouse-local component, the Apache SeaTunnel (Incubating) is used to generate the data files and compress the data. By communicating with the Server, the generated data is sent directly to the different nodes of Clickhouse and the data files are then made available to the nodes for the query.\\n\\nComparison of the original and current implementations.\\n\\n\\n\\n![](/image/20220510/en/3.png)\\n\\n\\n\\nOriginally, the data, including the insert statements was sent by Spark to the server, and the server did the SQL parsing, generated and compressed the table data files, generated the corresponding files, and created the corresponding indexes. If we use ClickHouse local technology, the data file generation, file compression and index creation are done by SeaTunnel, and the final output is a file or folder for the server-side, which is synchronized to the server and the server can queries the data without additional operations.\\n\\n\\n## 04 Core technical points\\n\\n\\n\\n![](/image/20220510/en/4.png)\\n\\n\\n\\nThe above process makes data synchronization more efficient, thanks to three optimizations we have made to it.\\n\\nFirstly, the data is transferred from the pipeline to the ClickHouseFile by the division, which imposes limitations in terms of length and memory. For this reason, we write the data received by the ClickHouse connector, i.e. the sink side, to a temporary file via MMAP technology, and then the ClickHouse local reads the data from the temporary file to generate our target local file, in order to achieve the effect of incremental data reading and solve the OM problem.\\n\\n\\n\\n![](/image/20220510/en/5.png)\\n\\n\\n\\nSecondly, it supports sharding. If only one file or folder is generated in a cluster, the file is distributed to only one node, which will greatly reduce the performance of the query. Therefore, we carry out slicing support. Users can set the key for slicing in the configuration folder, and the algorithm will divide the data into multiple log files and write them to different cluster nodes, significantly improving the read performance.\\n\\n\\n\\n![](/image/20220510/en/6.png)\\n\\n\\n\\nThe third key optimization is file transfer. Currently, SeaTunnel supports two file transfer methods, one is SCP, which is characterized by security, versatility, and no additional configuration; the other is RSYNC, which is somewhat fast and efficient and supports breakpoint resume, but requires additional configuration, users can choose between the way suits their needs.\\n\\n## 05 Plugin implementation analysis\\n\\nIn summary, the general implementation process of ClickHouseFile is as follows.\\n\\n\\n\\n![](/image/20220510/en/7.png)\\n\\n\\n\\n1.caching data to the ClickHouse sink side.\\n2.calling ClickHouse-local to generate the file.\\n3.sending the data to the ClickHouse server.\\n4.Execution of the ATTACH command.\\n\\nWith the above four steps, the generated data reaches a queryable state.\\n\\n## 06 Comparison of plug-in capabilities\\n\\n\\n\\n![](/image/20220510/en/8.png)\\n\\n\\n(a) In terms of data transfer, ClickHouseFile is more suitable for massive amounts of data, with the advantage that no additional configuration is required and it is highly versatile, while ClickHouseFile is more complex to configure and currently supports fewer engines.\\n\\nIn terms of environmental complexity, ClickHouse is more suitable for complex environments and can be run directly without additional configuration.\\n\\nIn terms of versatility, ClickHouse, due to being an officially supported JDBC diver by SeaTunnel, basically supports all engines for data writing, while ClickHouseFile supports relatively few engines.\\n\\nIn terms of server pressure, ClickHouseFile\'s advantage shows when it comes to massive data transfers that don\'t put too much pressure on the server.\\n\\nHowever, the two are not in competition and the choice needs to be based on the usage scenario.\\n\\n## 07 Follow-up plans\\n\\nAlthough SeaTunnel currently supports the ClickHouseFile plugin, there are still many defects that need to be optimized, mainly including\\n\\n- Rsync support.\\n- Exactly-Once support.\\n- Zero Copy support for transferring data files.\\n- More Engine support.\\n\\nAnyone interested in the above issues is welcome to contribute to the follow-up plans, or tell me your ideas!"},{"id":"SeaTunnel Application and Refactoring at Kidswant","metadata":{"permalink":"/blog/SeaTunnel Application and Refactoring at Kidswant","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2022-05-01_Kidswant.md","source":"@site/blog/2022-05-01_Kidswant.md","title":"SeaTunnel Application and Refactoring at Kidswant","description":"At the Apache SeaTunnel (Incubating) Meetup in April, Yuan Hongjun, a big data expert and OLAP platform architect at Kidswant, shared a topic of SeaTunnel Application and Refactoring at Kidswant.","date":"2022-05-01T00:00:00.000Z","formattedDate":"May 1, 2022","tags":[{"label":"Meetup","permalink":"/blog/tags/meetup"}],"readingTime":9.59,"truncated":false,"authors":[],"frontMatter":{"slug":"SeaTunnel Application and Refactoring at Kidswant","title":"SeaTunnel Application and Refactoring at Kidswant","tags":["Meetup"]},"prevItem":{"title":"How to synchronize tens of billions of data based on SeaTunnel\'s ClickHouse","permalink":"/blog/How to synchronize tens of billions of data based on SeaTunnel\'s ClickHouse"},"nextItem":{"title":"Innovation of Data Integration Technology in the Intelligent Era","permalink":"/blog/Innovation of Data Integration Technology in the Intelligent Era"}},"content":"![](/image/20220501/en/0.png)\\n\\nAt the Apache SeaTunnel (Incubating) Meetup in April, Yuan Hongjun, a big data expert and OLAP platform architect at Kidswant, shared a topic of SeaTunnel Application and Refactoring at Kidswant.\\n\\nThe presentation contains five parts.\\n\\n- Background of the introduction of Apache SeaTunnel (Incubating) by Kidswant\\n- A comparison of mainstream tools for big data processing\\n- The implementation of Apache SeaTunnel (Incubating)\\n- Common problems in Apache SeaTunnel (Incubating) refactoring\\n- Predictions on the future development of Kidswant\\n\\n\\n\\n![](/image/20220501/en/0-1.png)\\n\\n\\n\\nYuan Hongjun, Big data expert, OLAP platform architect of Kidswant. He has many years of experience in big data platform development and management, and has rich research experience in data assets, data lineage mapping, data governance, OLAP, and other fields.\\n\\n\\n## 01 Background\\n\\n\\n\\n![](/image/20220501/en/1.png)\\n\\n\\n\\nAt present, Kidswant\u2019s OLAP platform consists of seven parts: metadata layer, task layer, storage layer, SQL layer, scheduling layer, service layer, and monitoring layer. This sharing focuses on offline tasks in the task layer.\\n\\n\\nIn fact, Kidswant had a complete internal collection and push system, but due to some historical legacy issues, the company\u2019s existing platform could not quickly support the OLAP platform getting online, so at that time the company had to abandon its own platform and start developing a new system instead.\\nThere were three options in front of OLAP at the time.\\n\\n\\n1, Re-develop the collection and push system.\\n\\n\\n2\u3001Self-R&D.\\n\\n\\n3, Participate in open source projects.\\n\\n\\n## 02 Big data processing mainstream tools comparison\\n\\n\\nThese three options have their own pros and cons. Carrying re-research and development based on the collection and push system is convenient for us to take advantage of the experience of previous results and avoid repeatedly stepping into the pit. But the disadvantage is that it requires a large amount of code, time, a longer research period, and with less abstract code and lots of customized functions bound to the business, it\u2019s difficult to do the re-development.\\n\\n\\nIf completely self-developed, though the development process is autonomous and controllable, some engines such as Spark can be done to fit our own architecture, while the disadvantage is that we may encounter some unknown problems.\\n\\n\\nFor the last choice, if we use open-source frameworks, the advantage is that there is more abstract code, and the framework can be guaranteed in terms of performance and stability after verification by other major companies. Therefore Kidswant mainly studied three open-source data synchronization tools, DATAX, Sqoop, and SeaTunnel in the early stages of OLAP data synchronization refactoring.\\n\\n\\n![](/image/20220501/en/2.png)\\n\\n\\nFrom the diagram we can see that Sqoop\u2019s main function is data synchronization for RDB, and its implementation is based on MAP/REDUCE. Sqoop has rich parameters and command lines to perform various operations. The advantage of Sqoop is that it fits Hadoop ecology, and already supports most of the conversion from RDB to HIVE arbitrary source, with a complete set of commands and APIs.\\n\\n\\nThe disadvantages are that Sqoop only supports RDB data synchronization and has some limitations on data files, and there is no concept of data cleansing yet.\\n\\n\\n\\n![](/image/20220501/en/3.png)\\n\\n\\n\\nDataX mainly aims at synchronizing data from any source by configurable files + multi-threading, which runs three main processes: Reader, Framework, and Writer, where Framework mainly plays the role of communication and leaving empty space.\\n\\n\\nThe advantage of DataX is that it uses plug-in development, has its own flow control and data control, and is active in the community, with DataX\u2019s official website offering data pushes from many different sources. The disadvantage of DataX, however, is that it is memory-based and there may be limitations on the amount of data available.\\n\\n\\n\\n![](/image/20220501/en/4.png)\\n\\n\\n\\nApache SeaTunnel (Incubating) also does data synchronization from any source and implements the process in three steps: source, transform and sink based on configuration files, Spark or Flink. \\n\\nThe advantage is that the current 2.1.0 version has a very large number of plug-ins and source pushes, based on the idea of plug-ins also makes it very easy to extend and embrace Spark and Flink while with a distributed architecture. The only downside to Apache SeaTunnel (Incubating) is probably the lack of IP calls at the moment and the need to manage the UI interface by yourself.\\n\\n\\nIn summary, although Sqoop is distributed, it only supports data synchronization between RDB and HIVE, Hbase and has poor scalability, which is not convenient for re-development. DataX is scalable and stable overall, but because it is a standalone version, it cannot be deployed in a distributed cluster, and there is a strong dependency between data extraction capability and machine performance. SeaTunnel, on the other hand, is similar to DataX and makes up for the flaw of non-distributed DataX. It also supports real-time streaming, and the community is highly active as a new product. We chose SeaTunnel based on a number of factors such as whether it supported distributed or not, and whether it needed to be deployed on a separate machine.\\n\\n\\n## 03 Implementation\\n\\n\\nOn the Apache SeaTunnel (Incubating) website, we can see that the basic process of Apache SeaTunnel (Incubating) consists of three parts: source, transform and sink. According to the guidelines on the website, Apache SeaTunnel (Incubating) requires a configuration script to start, but after some research, we found that the final execution of Apache SeaTunnel (Incubating) is bansed on an application submitted by spark-submit that relies on the config file.\\n\\n\\nThis initialization, although simple, has the problem of having to rely on the config file, which is generated and then cleared after each run, and although it can be dynamically generated in the scheduling script, it raises two questions: 1) whether frequent disk operations make sense; and 2) whether there is a more efficient way to support Apache SeaTunnel (Incubating).\\n\\n\\n\\n![](/image/20220501/en/5.png)\\n\\n\\n\\nWith these considerations in mind, we added a Unified Configuration Template Platform module to the final design solution. Scheduling is done by initiating a commit command, and Apache SeaTunnel (Incubating) itself pulls the configuration information from the unified configuration template platform, then loads and initializes the parameters.\\n\\n\\n\\n![](/image/20220501/en/6.png)\\n\\n\\n\\nThe diagram above shows the business process for Kidswant\u2019s OLAP, which is divided into three sections. The overall flow of data from Parquet, i.e. Hive, through the Parquet tables to KYLIN and CK source.\\n\\n\\n\\n![](/image/20220501/en/7.png)\\n\\n\\n\\nThis is the page where we construct the model, which is generated mainly through drag and drop, with some transactional operations between each table, and micro-processing for Apache SeaTunnel (Incubating) on the right.\\n\\n\\n\\n![](/image/20220501/en/8.png)\\n\\n\\n\\nSo we end up submitting the commands as above, where the first one marked in red is [-conf customconfig/jars], referring to the fact that the user can then unify the configuration template platform for processing, or specify it separately when modeling. The last one marked in red is [421 $start_time $end_time $taskType] Unicode, which is a unique encoding.\\n\\n\\nBelow, on the left, are the 38 commands submitted by our final dispatch script. Below, on the right, is a modification made for Apache SeaTunnel (Incubating), and you can see a more specific tool class called WaterdropContext. It can first determine if Unicode exists and then use Unicode_code to get the configuration information for the different templates, avoiding the need to manipulate the config file.\\n\\n\\nIn the end, the reportMeta is used to report some information after the task is completed, which is also done in Apache SeaTunnel (Incubating).\\n\\n\\n\\n![](/image/20220501/en/9.png)\\n\\n\\n\\n\\n\\n![](/image/20220501/en/10.png)\\n\\n\\n\\n\\n![](/image/20220501/en/11.png)\\n\\n\\n\\nIn the finalized config file as above, it is worth noting that in terms of transforms, Kidswant has made some changes. The first is to do desensitization for mobile phones or ID numbers etc. If the user specifies a field, they do it by field, if not they will scan all fields and then desensitize and encrypt them according to pattern matching.\\n\\n\\nSecond, transform also supports custom processing, as mentioned above when talking about OLAP modeling. With the addition of HideStr, the first ten fields of a string of characters can be retained and all characters at the back encrypted, providing some security in the data.\\n\\n\\nThen, on the sink side, we added pre_sql in order to support the idempotency of the task, which is mainly done for tasks such as data deletion, or partition deletion, as the task cannot be run only once during production, and this design needed to account for the data deviation and correctness once operations such as reruns or complement occur.\\n\\n\\nOn the right side of the diagram, on the Sink side of a Clickhouse, we have added an is_senseless_mode, which forms a read/write senseless mode, where the user does not perceive the whole area when querying and complementing but uses the CK partition conversion, i.e. the command called MOVE PARTITION TO TABLE to operate.\\n\\n\\nA special note here is the Sink side of KYLIN. KYLIN is a very special source with its own set of data entry logic and its monitoring page, so the transformation we have done on KYLIN is simply a call to its API operation and a simple API call and constant polling of the state when using KYLIN, so the resources for KYLIN are limited in the Unified Template Configuration platform.\\n\\n\\n\\n\\n![](/image/20220501/en/12.png)\\n\\n\\n## 04 Common problems about the Apache SeaTunnel (Incubating) transformation\\n\\n\\n#### 01 OOM & Too Many Parts\\n\\n\\nThe problem usually arises during the Hive to Hive process, even if we go through automatic resource allocation, but there are cases where the data amount suddenly gets bigger, for example after holding several events. Such problems can only be avoided by manually and dynamically tuning the reference and adjusting the data synchronization batch time. In the future, we may try to control the data volume to achieve fine control.\\n\\n\\n#### 02 Field and type inconsistency issues\\n\\n\\nWhen the model runs, the user will make some changes to the upstream tables or fields that the task depends on, and these changes may lead to task failure if they are not perceived. The current solution is to rely on data lineage+ snapshots for advance awareness to avoid errors.\\n\\n\\n#### 03 Custom data sources & custom separators\\n\\n\\nIf the finance department requires a customized separator or jar information, the user can now specify the loading of additional jar information as well as the separator information themselves in the unified configuration template platform.\\n\\n\\n#### 04 Data skewing issues\\n\\n\\nThis may be due to users setting their parallelism but not being able to do so perfectly. We haven\u2019t finished dealing with this issue yet, but we may add post-processing to the Source module to break up the data and complete the skew.\\n\\n\\n#### 05 KYLIN global dictionary lock problem\\n\\n\\nAs the business grows, one cube will not be able to meet the needs of the users, so it will be necessary to create more than one cube. If the same fields are used between multiple cubes, the problem of KYLIN global dictionary lock will be encountered. The current solution is to separate the scheduling time between two or more tasks, or if this is not possible, we can make a distributed lock control, where the sink side of KYLIN has to get the lock to run.\\n\\n\\n## 05 An outlook on the future of Kidswant\\n\\n1. Multi-source data synchronization, maybe processing for RDB sources\\n2. Real-time Flink-based implementation\\n3. Take over the existing collection and scheduling platform (mainly to solve the problem of splitting library and tables)\\n4. Data quality verification, like some null values, the vacancy rate of the whole data, main time judgment, etc.\\n\\n\\nThis is all I have to share, I hope we can communicate more with the community in the future and make progress together, thanks!"},{"id":"Innovation of Data Integration Technology in the Intelligent Era","metadata":{"permalink":"/blog/Innovation of Data Integration Technology in the Intelligent Era","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2022-04-08-Innovation_of_Data_Integration_Technology_in_Intelligent_Era.md","source":"@site/blog/2022-04-08-Innovation_of_Data_Integration_Technology_in_Intelligent_Era.md","title":"Innovation of Data Integration Technology in the Intelligent Era","description":"1","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[{"label":"Meetup","permalink":"/blog/tags/meetup"}],"readingTime":3.735,"truncated":false,"authors":[],"frontMatter":{"slug":"Innovation of Data Integration Technology in the Intelligent Era","title":"Innovation of Data Integration Technology in the Intelligent Era","tags":["Meetup"]},"prevItem":{"title":"SeaTunnel Application and Refactoring at Kidswant","permalink":"/blog/SeaTunnel Application and Refactoring at Kidswant"},"nextItem":{"title":"2.1.0 Released! Apache SeaTunnel(Incubating) First Apache Release Refactors Kernel and Supports Flink Overall","permalink":"/blog/2.1.0-Released-Apache-SeaTunnel-Incubating-First-Apache-Release-Refactors-Kernel-and-Supports-Flink-Overall"}},"content":"![1](/image/20220416/EN/1.png)\\n\\n\\nAs we know, only manageable, callable, computable, and magnetizable data resources can be deposited as assets. The interconnection of information systems has created a huge demand for multi-source and multidimensional data integration, which imposes strict requirements on data processing and integration tools.\\n\\nIn the era of intelligence, under the trends of \u201csmart city\u201d, \u201csmart governance\u201d, and \u201cintelligent products\u201d, enterprises are mostly faced with the challenge of how to achieve efficient data push, improve platform quality, and ensure data security. Only by choosing the right data integration tools and platforms can data play a key role.\\n\\nAs a next-generation high-performance, distributed, and massive data integration framework, Apache SeaTunnel is committed to making data synchronization simpler and more efficient and accelerating the implementation of distributed data processing capabilities in the production environment.\\n\\nAt the Apache SeaTunnel Meetup (April 16, 2022), the community will invite experienced Apache SeaTunnel users to share the best practices of the project in intelligent production environments. In addition, there will be contributors to analyze the source code of Apache SeaTunnel, guiding you to have a comprehensive and in-depth understanding of this powerful data integration tool.\\n\\nWhether you are a beginner who is interested in Apache SeaTunnel or users who encounter complex and difficult deployment problems in daily practice, you can come here to communicate with our instructors and get the answers you want.\\n\\n## 01 Sign up\\n\\nApache SeaTunnel Meetup | April online live registration has been started, hurry up and register!\\n\\nTime: 2022\u20134\u201316 14:00\u201317:00\\n\\nFormat: live online\\n\\nClick the link to register (free):\xa0[https://www.slidestalk.com/m/780](https://www.slidestalk.com/m/780)\\n\\nJoin Slack:\\n\\n[https://join.slack.com/t/apacheseatunnel/shared_invite/zt-10u1eujlc-g4E~ppbinD0oKpGeoo_dAw](https://join.slack.com/t/apacheseatunnel/shared_invite/zt-10u1eujlc-g4E~ppbinD0oKpGeoo_dAw)\\n\\n## 02 Highlights\\n\\n* Detailed case study\\n* Feature Analysis\\n* Tips to avoid stepping into the pit from enterprises\\n* Open-source community growth strategy\\n* Face-to-face Q&A with industry technical experts\\n* Surprise gifts\\n## 03 Event Agenda\\n\\nOn the day of the event, big data engineers from Kidswant and oppo will share the front-line practical experience, and senior engineers from WhaleOps will give a \u201chard-core\u201d explanation of the important function updates of Apache SeaTunnel.\\n\\n\\n![2](/image/20220416/EN/2.png)\\n\\n\\nYuan Hongjun, Kidswant Big Data Expert, OLAP Platform Architect\\n\\nYears of experience in R&D and management of big data platforms, rich research experience in data assets, data linkage, data governance, OLAP, and other fields\\n\\nTime: 14:00\u201314:40\\n\\nTopic: Application Practice of Apache SeaTunnel in Kidswant\\n\\nSpeech outline: How to push data efficiently? How to improve the quality of the platform? How to ensure data security? What changes did Kidswant make to Apache SeaTunnel?\\n\\n\\n![3](/image/20220416/EN/3.png)\\n\\n\\nFan Jia, WhaleOps Senior Engineer\\n\\nTime: 14:40\u201315:20\\n\\nTopic: Clickhouse Bulk Load Implementation Based on Apache SeaTunnel\\n\\nSpeech outline: How to implement the bulk load data synchronization function of Clickhouse by extending the Connector of Apache SeaTunnel?\\n\\n\\n![4](/image/20220416/EN/4.png)\\n\\n\\nWang Zichao, Oppo Senior Backend Engineer\\n\\nTime: 15:50\u201316:30\\n\\nTopic: The technological innovation of oppo intelligent recommendation sample center based on Apache SeaTunnel\\n\\nSpeech outline: Introduce the evolution of oppo\u2019s intelligent recommendation machine learning sample dealing process and the role of Apache SeaTunnel in it.\\n\\nIn addition to the wonderful speeches, a number of lucky draw sessions were also set up on the meetup. Anyone participating in the lucky draw will have the opportunity to win exquisite customized gifts from Apache SeaTunnel, so stay tuned~\\n\\n## **About SeaTunnel**\\n\\nSeaTunnel (formerly Waterdrop) is an easy-to-use, ultra-high-performance distributed data integration platform that supports real-time synchronization of massive amounts of data and can synchronize hundreds of billions of data per day in a stable and efficient manner.\\n\\n## **Why do we need SeaTunnel?**\\n\\nSeaTunnel does everything it can to solve the problems you may encounter in synchronizing massive amounts of data.\\n\\n* Data loss and duplication\\n* Task buildup and latency\\n* Low throughput\\n* Long application-to-production cycle time\\n* Lack of application status monitoring\\n## **SeaTunnel Usage Scenarios**\\n\\n* Massive data synchronization\\n* Massive data integration\\n* ETL of large volumes of data\\n* Massive data aggregation\\n* Multi-source data processing\\n## **Features of SeaTunnel**\\n\\n* Rich components\\n* High scalability\\n* Easy to use\\n* Mature and stable\\n## **How to get started with SeaTunnel quickly?**\\n\\nWant to experience SeaTunnel quickly? SeaTunnel 2.1.0 takes 10 seconds to get you up and running.\\n\\n[https://seatunnel.apache.org/docs/2.1.0/developement/setup](https://seatunnel.apache.org/docs/2.1.0/developement/setup)\\n\\n## **How can I contribute?**\\n\\nWe invite all partners who are interested in making local open-source global to join the SeaTunnel contributors family and foster open-source together!\\n\\nSubmit an issue:\\n\\n[https://github.com/apache/incubator-seatunnel/issues](https://github.com/apache/incubator-seatunnel/issues)\\n\\nContribute code to:\\n\\n[https://github.com/apache/incubator-seatunnel/pulls](https://github.com/apache/incubator-seatunnel/pulls)\\n\\nSubscribe to the community development mailing list :\\n\\ndev-subscribe@seatunnel.apache.org\\n\\nDevelopment Mailing List :\\n\\ndev@seatunnel.apache.org\\n\\nJoin Slack:\\n\\n[https://join.slack.com/t/apacheseatunnel/shared_invite/zt-123jmewxe-RjB_DW3M3gV~xL91pZ0oVQ](https://join.slack.com/t/apacheseatunnel/shared_invite/zt-123jmewxe-RjB_DW3M3gV~xL91pZ0oVQ)\\n\\nFollow Twitter:\\n\\n[https://twitter.com/ASFSeaTunnel](https://twitter.com/ASFSeaTunnel)\\n\\nCome and join us!"},{"id":"2.1.0-Released-Apache-SeaTunnel-Incubating-First-Apache-Release-Refactors-Kernel-and-Supports-Flink-Overall","metadata":{"permalink":"/blog/2.1.0-Released-Apache-SeaTunnel-Incubating-First-Apache-Release-Refactors-Kernel-and-Supports-Flink-Overall","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2022-03-18-2-1-0-release.md","source":"@site/blog/2022-03-18-2-1-0-release.md","title":"2.1.0 Released! Apache SeaTunnel(Incubating) First Apache Release Refactors Kernel and Supports Flink Overall","description":"On December 9, 2021, Apache SeaTunnel(Incubating) entered the Apache Incubator, and after nearly four months of endeavor by the community contributors, we passed the first Apache version control in one go and released it on March 18, 2022. This means that version 2.1.0 is an official release that is safe for corporate and individual users to use, which has been voted on by the Apache SeaTunnel(Incubating) community and the Apache Incubator.","date":"2022-03-18T00:00:00.000Z","formattedDate":"March 18, 2022","tags":[{"label":"2.1.0","permalink":"/blog/tags/2-1-0"},{"label":"Release","permalink":"/blog/tags/release"}],"readingTime":5.005,"truncated":false,"authors":[],"frontMatter":{"slug":"2.1.0-Released-Apache-SeaTunnel-Incubating-First-Apache-Release-Refactors-Kernel-and-Supports-Flink-Overall","title":"2.1.0 Released! Apache SeaTunnel(Incubating) First Apache Release Refactors Kernel and Supports Flink Overall","tags":["2.1.0","Release"]},"prevItem":{"title":"Innovation of Data Integration Technology in the Intelligent Era","permalink":"/blog/Innovation of Data Integration Technology in the Intelligent Era"},"nextItem":{"title":"How to quickly import data from HDFS into ClickHouse","permalink":"/blog/hdfs-to-clickhouse"}},"content":"On December 9, 2021, Apache SeaTunnel(Incubating) entered the Apache Incubator, and after nearly four months of endeavor by the community contributors, we passed the first Apache version control in one go and released it on March 18, 2022. This means that version 2.1.0 is an official release that is safe for corporate and individual users to use, which has been voted on by the Apache SeaTunnel(Incubating) community and the Apache Incubator.\\n\\n**Note:** A\xa0**software license**\xa0is a legal instrument governing the use or redistribution of software. A typical software license grants the\xa0licensee, typically an\xa0end-user, permission to use one or more copies of the software in ways where such a use would otherwise potentially constitute copyright infringement of the software owner\'s\xa0exclusive rights\xa0under copyright. Effectively, a software license is a contract between the software developer and the user that guarantees the user will not be sued within the scope of the license. \\n\\nBefore and after entering the incubator, we spent a lot of time sorting through the external dependencies of the entire project to ensure compliance. It is important to note that the choice of License for open source software does not necessarily mean that the project itself is compliant. While the stringent version control process of ASF ensures compliance and legal distribution of the software license maximumly.\\n\\n## Release Note\\n\\nWe bring the following **key features**to this release:\\n\\n1. The kernel of the microkernel plug-in architecture is overall optimized, which is mainly in Java. And a lot of improvements are made to command line parameter parsing, plug-in loading, etc. At the same time, the users (or contributors) can choose the language to develop plug-in extensions, which greatly reduces the development threshold of plug-ins.\\n2. Overall support for Flink, while the users are free to choose the underlying engine. This version also brings a large number of Flink plug-ins and welcomes anyone to contribute more.\\n3. Provide local development fast startup environment support (example), allow contributors or users quickly and smoothly start without changing any code to facilitate rapid local development debugging. This is certainly exciting news for contributors or users who need to customize their plugins. In fact, we\'ve had a large number of contributors use this approach to quickly test the plugin in our pre-release testing.\\n4. With Docker container installation provided, users can deploy and install Apache SeaTunnel(Incubating) via Docker extremely fast, and we will iterate around Docker & K8s in the future, any interesting proposal on this is welcomed.\\n## Specific release notes\uff1a\\n\\n### [Features]\\n\\n* Use JCommander to do command line parameter parsing, making developers focus on the logic itself.\\n* Flink is upgraded from 1.9 to 1.13.5, keeping compatibility with older versions and preparing for subsequent CDC.\\n* Support for Doris, Hudi, Phoenix, Druid, and other Connector plugins, and you can find complete plugin support here [plugins-supported-by-seatunnel]([https://github.com/apache/incubator-seatunnel#plugins-supported-by-seatunnel](https://github.com/apache/incubator-seatunnel#plugins-supported-by-seatunnel)).\\n* Local development extremely fast starts environment support. It can be achieved by using the example module without modifying any code, which is convenient for local debugging.\\n* Support for installing and trying out Apache SeaTunnel(Incubating) via Docker containers.\\n* SQL component supports SET statements and configuration variables.\\n* Config module refactoring to facilitate understanding for the contributors while ensuring code compliance (License) of the project.\\n* Project structure realigned to fit the new Roadmap.\\n* CI&CD support, code quality automation control (more plans will be carried out to support CI&CD development).\\n\\n## Acknowledgments\\n\\nThanks to the following contributors who participated in this version release (GitHub IDs, in no particular order).\\n\\nAl-assad, BenJFan, CalvinKirs, JNSimba, JiangTChen, Rianico, TyrantLucifer, Yves-yuan, ZhangchengHu0923, agendazhang, an-shi-chi-fan, asdf2014, bigdataf, chaozwn, choucmei, dailidong, dongzl, felix-thinkingdata, fengyuceNv, garyelephant, kalencaya, kezhenxu94, legendtkl, leo65535, liujinhui1994, mans2singh, marklightning, mosence, nielifeng, ououtt, ruanwenjun, simon824, totalo, wntp, wolfboys, wuchunfu, xbkaishui, xtr1993, yx91490, zhangbutao, zhaomin1423, zhongjiajie, zhuangchong, zixi0825.\\n\\nAlso sincere gratitude to our Mentors: Zhenxu Ke, Willem Jiang, William Guo, LiDong Dai, Ted Liu, Kevin, JB for their help!\\n\\n## Planning for the next few releases:\\n\\n* CDC support.\\n* Support for the monitoring system.\\n* UI system support.\\n* More Connector and efficient Sink support, such as ClickHouse support will be available in the next release soon.\\nThe follow-up **Features** are decided by the community consensus, and we sincerely appeal to more participation in the community construction.\\n\\nWe need your attention and contributions:)\\n\\n## Community Status\\n\\n### Recent Development\\n\\nSince entering the Apache incubator, the contributor group has grown from 13 to 55 and continues to grow, with the average weekly community commits remaining at 20+. \\n\\nThree contributors from different companies (Lei Xie, HuaJie Wang, Chunfu Wu) have been invited to become Committers on account of their contributions to the community. \\n\\nWe held two Meetups, where instructors from Bilibili, OPPO, Vipshop, and other companies shared their large-scale production practices based on SeaTunnel in their companies (we will hold one meetup monthly in the future, and welcome SeaTunnel users or contributors to come and share their stories about SeaTunnel).\\n\\n### Users of Apache SeaTunnel(Incubating)\\n\\nNote: Only registered users are included.\\n\\nRegistered users of Apache SeaTunnel(Incubating) are shown below. If you are also using Apache SeaTunnel(Incubating), too, welcome to register on [Who is using SeaTunne](https://github.com/apache/incubator-seatunnel/issues/686)!\\n\\n<div align=\\"center\\">\\n\\n<img src=\\"/image/20220321/1.png\\"/>\\n\\n</div>\\n\\n## PPMC\'s Word\\n\\nLiFeng Nie, PPMC of Apache SeaTunnel(Incubating), commented on the first Apache version release. \\n\\nFrom the first day entering Apache Incubating, we have been working hard to learn the Apache Way and various Apache policies. Although the first release took a lot of time (mainly for compliance), we think it was well worth it, and that\'s one of the reasons we chose to enter Apache. We need to give our users peace of mind, and Apache is certainly the best choice, with its almost demanding license control that allows users to avoid compliance issues as much as possible and ensure that the software is circulating reasonably and legally. In addition, its practice of the Apache Way, such as public service mission, pragmatism, community over code, openness and consensus decision-making, and meritocracy, can drive the Apache SeaTunnel(Incubating) community to become more open, transparent, and diverse."},{"id":"hdfs-to-clickhouse","metadata":{"permalink":"/blog/hdfs-to-clickhouse","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2021-12-30-hdfs-to-clickhouse.md","source":"@site/blog/2021-12-30-hdfs-to-clickhouse.md","title":"How to quickly import data from HDFS into ClickHouse","description":"ClickHouse is a distributed columnar DBMS for OLAP. Our department has now stored all log data related to data analysis in ClickHouse, an excellent data warehouse, and the current daily data volume has reached 30 billion.","date":"2021-12-30T00:00:00.000Z","formattedDate":"December 30, 2021","tags":[{"label":"HDFS","permalink":"/blog/tags/hdfs"},{"label":"ClickHouse","permalink":"/blog/tags/click-house"}],"readingTime":5.455,"truncated":false,"authors":[],"frontMatter":{"slug":"hdfs-to-clickhouse","title":"How to quickly import data from HDFS into ClickHouse","tags":["HDFS","ClickHouse"]},"prevItem":{"title":"2.1.0 Released! Apache SeaTunnel(Incubating) First Apache Release Refactors Kernel and Supports Flink Overall","permalink":"/blog/2.1.0-Released-Apache-SeaTunnel-Incubating-First-Apache-Release-Refactors-Kernel-and-Supports-Flink-Overall"},"nextItem":{"title":"How to quickly import data from Hive into ClickHouse","permalink":"/blog/hive-to-clickhouse"}},"content":"ClickHouse is a distributed columnar DBMS for OLAP. Our department has now stored all log data related to data analysis in ClickHouse, an excellent data warehouse, and the current daily data volume has reached 30 billion.\\n\\nThe experience of data processing and storage introduced earlier is based on real-time data streams. The data is stored in Kafka. We use Java or Golang to read, parse, and clean the data from Kafka and write it into ClickHouse, so that the data can be stored in ClickHouse. Quick access. However, in the usage scenarios of many students, the data is not real-time, and it may be necessary to import the data in HDFS or Hive into ClickHouse. Some students implement data import by writing Spark programs, so is there a simpler and more efficient way?\\n\\nAt present, there is a tool **Seatunnel** in the open source community, the project address [https://github.com/apache/incubator-seatunnel](https://github.com/apache/incubator-seatunnel), can quickly Data in HDFS is imported into ClickHouse.\\n\\n## HDFS To ClickHouse\\n\\nAssuming that our logs are stored in HDFS, we need to parse the logs and filter out the fields we care about, and write the corresponding fields into the ClickHouse table.\\n\\n### Log Sample\\n\\nThe log format we store in HDFS is as follows, which is a very common Nginx log\\n\\n```shell\\n10.41.1.28 github.com 114.250.140.241 0.001s \\"127.0.0.1:80\\" [26/Oct/2018:03:09:32 +0800] \\"GET /Apache/Seatunnel HTTP/1.1\\" 200 0 \\"-\\" - \\"Dalvik/2.1.0 (Linux; U; Android 7.1.1; OPPO R11 Build/NMF26X)\\" \\"196\\" \\"-\\" \\"mainpage\\" \\"443\\" \\"-\\" \\"172.16.181.129\\"\\n```\\n\\n### ClickHouse Schema\\n\\nOur ClickHouse table creation statement is as follows, our table is partitioned by day\\n\\n```shell\\nCREATE TABLE cms.cms_msg\\n(\\n    date Date, \\n    datetime DateTime, \\n    url String, \\n    request_time Float32, \\n    status String, \\n    hostname String, \\n    domain String, \\n    remote_addr String, \\n    data_size Int32, \\n    pool String\\n) ENGINE = MergeTree PARTITION BY date ORDER BY date SETTINGS index_granularity = 16384\\n```\\n\\n## Seatunnel with ClickHouse\\n\\nNext, I will introduce to you in detail how we can meet the above requirements through Seatunnel and write the data in HDFS into ClickHouse.\\n\\n### Seatunnel\\n\\n[Seatunnel](https://github.com/apache/incubator-seatunnel) is a very easy-to-use, high-performance, real-time data processing product that can deal with massive data. It is built on Spark. Seatunnel has a very rich set of plugins that support reading data from Kafka, HDFS, Kudu, performing various data processing, and writing the results to ClickHouse, Elasticsearch or Kafka.\\n\\n### Prerequisites\\n\\nFirst we need to install Seatunnel, the installation is very simple, no need to configure system environment variables\\n\\n1. Prepare the Spark environment\\n2. Install Seatunnel\\n3. Configure Seatunnel\\n\\nThe following are simple steps, the specific installation can refer to [Quick Start](/docs/quick-start)\\n\\n```shell\\ncd /usr/local\\n\\nwget https://archive.apache.org/dist/spark/spark-2.2.0/spark-2.2.0-bin-hadoop2.7.tgz\\ntar -xvf https://archive.apache.org/dist/spark/spark-2.2.0/spark-2.2.0-bin-hadoop2.7.tgz\\n\\nwget https://github.com/InterestingLab/seatunnel/releases/download/v1.1.1/seatunnel-1.1.1.zip\\n\\nunzip seatunnel-1.1.1.zip\\n\\ncd seatunnel-1.1.1\\nvim config/seatunnel-env.sh\\n\\n# Specify the Spark installation path\\nSPARK_HOME=${SPARK_HOME:-/usr/local/spark-2.2.0-bin-hadoop2.7}\\n```\\n\\n### seatunnel Pipeline\\n\\nWe only need to write a configuration file of seatunnel Pipeline to complete the data import.\\n\\nThe configuration file consists of four parts, Spark, Input, filter and Output.\\n\\n#### Spark\\n\\nThis part is the related configuration of Spark, which mainly configures the size of the resources required for Spark to execute.\\n\\n```shell\\nspark {\\n  spark.app.name = \\"seatunnel\\"\\n  spark.executor.instances = 2\\n  spark.executor.cores = 1\\n  spark.executor.memory = \\"1g\\"\\n}\\n```\\n\\n#### Input\\n\\nThis part defines the data source. The following is a configuration example for reading data in text format from HDFS files.\\n\\n```shell\\ninput {\\n    hdfs {\\n        path = \\"hdfs://nomanode:8020/rowlog/accesslog\\"\\n        table_name = \\"access_log\\"\\n        format = \\"text\\"\\n    }\\n}\\n```\\n\\n#### Filter\\n\\nIn the Filter section, here we configure a series of transformations, including regular parsing to split the log, time transformation to convert HTTPDATE to the date format supported by ClickHouse, type conversion to Number type fields, and field filtering through SQL, etc.\\n\\n```shell\\nfilter {\\n    # Parse raw logs using regular expressions\\n    grok {\\n        source_field = \\"raw_message\\"\\n        pattern = \'%{IP:ha_ip}\\\\\\\\s%{NOTSPACE:domain}\\\\\\\\s%{IP:remote_addr}\\\\\\\\s%{NUMBER:request_time}s\\\\\\\\s\\\\\\"%{DATA:upstream_ip}\\\\\\"\\\\\\\\s\\\\\\\\[%{HTTPDATE:timestamp}\\\\\\\\]\\\\\\\\s\\\\\\"%{NOTSPACE:method}\\\\\\\\s%{DATA:url}\\\\\\\\s%{NOTSPACE:http_ver}\\\\\\"\\\\\\\\s%{NUMBER:status}\\\\\\\\s%{NUMBER:body_bytes_send}\\\\\\\\s%{DATA:referer}\\\\\\\\s%{NOTSPACE:cookie_info}\\\\\\\\s\\\\\\"%{DATA:user_agent}\\\\\\"\\\\\\\\s%{DATA:uid}\\\\\\\\s%{DATA:session_id}\\\\\\\\s\\\\\\"%{DATA:pool}\\\\\\"\\\\\\\\s\\\\\\"%{DATA:tag2}\\\\\\"\\\\\\\\s%{DATA:tag3}\\\\\\\\s%{DATA:tag4}\'\\n    }\\n\\n    # Convert data in \\"dd/MMM/yyyy:HH:mm:ss Z\\" format to\\n    # Data in \\"yyyy/MM/dd HH:mm:ss\\" format\\n    date {\\n        source_field = \\"timestamp\\"\\n        target_field = \\"datetime\\"\\n        source_time_format = \\"dd/MMM/yyyy:HH:mm:ss Z\\"\\n        target_time_format = \\"yyyy/MM/dd HH:mm:ss\\"\\n    }\\n\\n    # Use SQL to filter the fields of interest and process the fields\\n    # You can even filter out data you don\'t care about by filter conditions\\n    sql {\\n        table_name = \\"access\\"\\n        sql = \\"select substring(date, 1, 10) as date, datetime, hostname, url, http_code, float(request_time), int(data_size), domain from access\\"\\n    }\\n}\\n```\\n\\n#### Output\\n\\nFinally, we write the processed structured data to ClickHouse\\n\\n```shell\\noutput {\\n    clickhouse {\\n        host = \\"your.clickhouse.host:8123\\"\\n        database = \\"seatunnel\\"\\n        table = \\"access_log\\"\\n        fields = [\\"date\\", \\"datetime\\", \\"hostname\\", \\"uri\\", \\"http_code\\", \\"request_time\\", \\"data_size\\", \\"domain\\"]\\n        username = \\"username\\"\\n        password = \\"password\\"\\n    }\\n}\\n```\\n\\n### Running seatunnel\\n\\nWe combine the above four-part configuration into our configuration file `config/batch.conf`.\\n\\n```shell\\nvim config/batch.conf\\n```\\n\\n```shell\\nspark {\\n  spark.app.name = \\"seatunnel\\"\\n  spark.executor.instances = 2\\n  spark.executor.cores = 1\\n  spark.executor.memory = \\"1g\\"\\n}\\n\\ninput {\\n    hdfs {\\n        path = \\"hdfs://nomanode:8020/rowlog/accesslog\\"\\n        table_name = \\"access_log\\"\\n        format = \\"text\\"\\n    }\\n}\\n\\nfilter {\\n    # Parse raw logs using regular expressions\\n    grok {\\n        source_field = \\"raw_message\\"\\n        pattern = \'%{IP:ha_ip}\\\\\\\\s%{NOTSPACE:domain}\\\\\\\\s%{IP:remote_addr}\\\\\\\\s%{NUMBER:request_time}s\\\\\\\\s\\\\\\"%{DATA:upstream_ip}\\\\\\"\\\\\\\\s\\\\\\\\[%{HTTPDATE:timestamp}\\\\\\\\]\\\\\\\\s\\\\\\"%{NOTSPACE:method}\\\\\\\\s%{DATA:url}\\\\\\\\s%{NOTSPACE:http_ver}\\\\\\"\\\\\\\\s%{NUMBER:status}\\\\\\\\s%{NUMBER:body_bytes_send}\\\\\\\\s%{DATA:referer}\\\\\\\\s%{NOTSPACE:cookie_info}\\\\\\\\s\\\\\\"%{DATA:user_agent}\\\\\\"\\\\\\\\s%{DATA:uid}\\\\\\\\s%{DATA:session_id}\\\\\\\\s\\\\\\"%{DATA:pool}\\\\\\"\\\\\\\\s\\\\\\"%{DATA:tag2}\\\\\\"\\\\\\\\s%{DATA:tag3}\\\\\\\\s%{DATA:tag4}\'\\n    }\\n\\n    # Convert data in \\"dd/MMM/yyyy:HH:mm:ss Z\\" format to\\n    # Data in \\"yyyy/MM/dd HH:mm:ss\\" format\\n    date {\\n        source_field = \\"timestamp\\"\\n        target_field = \\"datetime\\"\\n        source_time_format = \\"dd/MMM/yyyy:HH:mm:ss Z\\"\\n        target_time_format = \\"yyyy/MM/dd HH:mm:ss\\"\\n    }\\n\\n    # Use SQL to filter the fields of interest and process the fields\\n    # You can even filter out data you don\'t care about by filter conditions\\n    sql {\\n        table_name = \\"access\\"\\n        sql = \\"select substring(date, 1, 10) as date, datetime, hostname, url, http_code, float(request_time), int(data_size), domain from access\\"\\n    }\\n}\\n\\noutput {\\n    clickhouse {\\n        host = \\"your.clickhouse.host:8123\\"\\n        database = \\"seatunnel\\"\\n        table = \\"access_log\\"\\n        fields = [\\"date\\", \\"datetime\\", \\"hostname\\", \\"uri\\", \\"http_code\\", \\"request_time\\", \\"data_size\\", \\"domain\\"]\\n        username = \\"username\\"\\n        password = \\"password\\"\\n    }\\n}\\n```\\n\\nExecute the command, specify the configuration file, and run Seatunnel to write data to ClickHouse. Here we take the local mode as an example.\\n\\n```shell\\n./bin/start-seatunnel.sh --config config/batch.conf -e client -m \'local[2]\'\\n```\\n\\n## Conclusion\\n\\nIn this post, we covered how to import Nginx log files from HDFS into ClickHouse using Seatunnel. Data can be imported quickly with only one configuration file without writing any code. In addition to supporting HDFS data sources, Seatunnel also supports real-time reading and processing of data from Kafka to ClickHouse. Our next article will describe how to quickly import data from Hive into ClickHouse.\\n\\nOf course, Seatunnel is not only a tool for ClickHouse data writing, but also plays a very important role in the writing of data sources such as Elasticsearch and Kafka.\\n\\nIf you want to know more functions and cases of Seatunnel combined with ClickHouse, Elasticsearch and Kafka, you can go directly to the official website [https://seatunnel.apache.org/](https://seatunnel.apache.org/)\\n\\n-- Power by [InterestingLab](https://github.com/InterestingLab)"},{"id":"hive-to-clickhouse","metadata":{"permalink":"/blog/hive-to-clickhouse","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2021-12-30-hive-to-clickhouse.md","source":"@site/blog/2021-12-30-hive-to-clickhouse.md","title":"How to quickly import data from Hive into ClickHouse","description":"ClickHouse is a distributed columnar DBMS for OLAP. Our department has stored all log data related to data analysis in ClickHouse, an excellent data warehouse, and the current daily data volume has reached 30 billion.","date":"2021-12-30T00:00:00.000Z","formattedDate":"December 30, 2021","tags":[{"label":"Hive","permalink":"/blog/tags/hive"},{"label":"ClickHouse","permalink":"/blog/tags/click-house"}],"readingTime":4.215,"truncated":false,"authors":[],"frontMatter":{"slug":"hive-to-clickhouse","title":"How to quickly import data from Hive into ClickHouse","tags":["Hive","ClickHouse"]},"prevItem":{"title":"How to quickly import data from HDFS into ClickHouse","permalink":"/blog/hdfs-to-clickhouse"},"nextItem":{"title":"How to quickly write data to Elasticsearch using Spark","permalink":"/blog/spark-execute-elasticsearch"}},"content":"ClickHouse is a distributed columnar DBMS for OLAP. Our department has stored all log data related to data analysis in ClickHouse, an excellent data warehouse, and the current daily data volume has reached 30 billion.\\n\\nIn the previous article [How to quickly import data from HDFS into ClickHouse] (2021-12-30-hdfs-to-clickhouse.md), we mentioned the use of Seatunnel [https://github.com/apache/incubator -seatunnel](https://github.com/apache/incubator-seatunnel) After a very simple operation on the data in HDFS, the data can be written to ClickHouse. The data in HDFS is generally unstructured data, so what should we do with the structured data stored in Hive?\\n\\n![](/doc/image_zh/hive-logo.png)\\n\\n## Hive to ClickHouse\\n\\nAssuming that our data has been stored in Hive, we need to read the data in the Hive table and filter out the fields we care about, or convert the fields, and finally write the corresponding fields into the ClickHouse table.\\n\\n### Hive Schema\\n\\nThe structure of the data table we store in Hive is as follows, which stores common Nginx logs.\\n\\n```\\nCREATE TABLE `nginx_msg_detail`(\\n   `hostname` string,\\n   `domain` string,\\n   `remote_addr` string,\\n   `request_time` float,\\n   `datetime` string,\\n   `url` string,\\n   `status` int,\\n   `data_size` int,\\n   `referer` string,\\n   `cookie_info` string,\\n   `user_agent` string,\\n   `minute` string)\\n PARTITIONED BY (\\n   `date` string,\\n   `hour` string)\\n\\n```\\n\\n### ClickHouse Schema\\n\\nOur ClickHouse table creation statement is as follows, our table is partitioned by day\\n\\n```\\nCREATE TABLE cms.cms_msg\\n(\\n    date Date,\\n    datetime DateTime,\\n    url String,\\n    request_time Float32,\\n    status String,\\n    hostname String,\\n    domain String,\\n    remote_addr String,\\n    data_size Int32\\n) ENGINE = MergeTree PARTITION BY date ORDER BY (date, hostname) SETTINGS index_granularity = 16384\\n```\\n\\n## Seatunnel with ClickHouse\\n\\nNext, I will introduce to you how we write data from Hive to ClickHouse through Seatunnel.\\n\\n### Seatunnel\\n\\n[Seatunnel](https://github.com/apache/incubator-seatunnel) is a very easy-to-use, high-performance, real-time data processing product that can deal with massive data. It is built on Spark. Seatunnel has a very rich set of plug-ins that support reading data from Kafka, HDFS, and Kudu, performing various data processing, and writing the results to ClickHouse, Elasticsearch or Kafka.\\n\\nThe environment preparation and installation steps of Seatunnel will not be repeated here. For specific installation steps, please refer to the previous article or visit [Seatunnel Docs](/docs/intro/about)\\n\\n### Seatunnel Pipeline\\n\\nWe only need to write a configuration file of Seatunnel Pipeline to complete the data import.\\n\\nThe configuration file includes four parts, namely Spark, Input, filter and Output.\\n\\n#### Spark\\n\\n\\nThis part is the related configuration of Spark, which mainly configures the resource size required for Spark execution.\\n\\n```\\nspark {\\n  // This configuration is required\\n  spark.sql.catalogImplementation = \\"hive\\"\\n  spark.app.name = \\"seatunnel\\"\\n  spark.executor.instances = 2\\n  spark.executor.cores = 1\\n  spark.executor.memory = \\"1g\\"\\n}\\n```\\n\\n#### Input\\n\\nThis part defines the data source. The following is a configuration example of reading data in text format from a Hive file.\\n\\n```\\ninput {\\n    hive {\\n        pre_sql = \\"select * from access.nginx_msg_detail\\"\\n        table_name = \\"access_log\\"\\n    }\\n}\\n```\\n\\nSee, a very simple configuration can read data from Hive. `pre_sql` is the SQL to read data from Hive, and `table_name` is the name of the table that will register the read data as a temporary table in Spark, which can be any field.\\n\\nIt should be noted that it must be ensured that the metastore of hive is in the service state.\\n\\nWhen running in Cluster, Client, Local mode, the `hive-site.xml` file must be placed in the $HADOOP_CONF directory of the submit task node\\n\\n#### Filter\\n\\nIn the Filter section, here we configure a series of transformations, and here we discard the unnecessary minute and hour fields. Of course, we can also not read these fields through `pre_sql` when reading Hive\\n\\n```\\nfilter {\\n    remove {\\n        source_field = [\\"minute\\", \\"hour\\"]\\n    }\\n}\\n```\\n\\n#### Output\\n\\nFinally, we write the processed structured data to ClickHouse\\n\\n```\\noutput {\\n    clickhouse {\\n        host = \\"your.clickhouse.host:8123\\"\\n        database = \\"seatunnel\\"\\n        table = \\"nginx_log\\"\\n        fields = [\\"date\\", \\"datetime\\", \\"hostname\\", \\"url\\", \\"http_code\\", \\"request_time\\", \\"data_size\\", \\"domain\\"]\\n        username = \\"username\\"\\n        password = \\"password\\"\\n    }\\n}\\n```\\n\\n### Running Seatunnel\\n\\nWe combine the above four-part configuration into our configuration file `config/batch.conf`.\\n\\n    vim config/batch.conf\\n\\n```\\nspark {\\n  spark.app.name = \\"seatunnel\\"\\n  spark.executor.instances = 2\\n  spark.executor.cores = 1\\n  spark.executor.memory = \\"1g\\"\\n  // This configuration is required\\n  spark.sql.catalogImplementation = \\"hive\\"\\n}\\ninput {\\n    hive {\\n        pre_sql = \\"select * from access.nginx_msg_detail\\"\\n        table_name = \\"access_log\\"\\n    }\\n}\\nfilter {\\n    remove {\\n        source_field = [\\"minute\\", \\"hour\\"]\\n    }\\n}\\noutput {\\n    clickhouse {\\n        host = \\"your.clickhouse.host:8123\\"\\n        database = \\"seatunnel\\"\\n        table = \\"access_log\\"\\n        fields = [\\"date\\", \\"datetime\\", \\"hostname\\", \\"uri\\", \\"http_code\\", \\"request_time\\", \\"data_size\\", \\"domain\\"]\\n        username = \\"username\\"\\n        password = \\"password\\"\\n    }\\n}\\n```\\n\\nExecute the command, specify the configuration file, and run Seatunnel to write data to ClickHouse. Here we take the local mode as an example.\\n\\n    ./bin/start-seatunnel.sh --config config/batch.conf -e client -m \'local[2]\'\\n\\n\\n## Conclusion\\n\\nIn this post, we covered how to import data from Hive into ClickHouse using Seatunnel. The data import can be completed quickly through only one configuration file without writing any code, which is very simple.\\n\\nIf you want to know more functions and cases of Seatunnel combined with ClickHouse, Elasticsearch, Kafka, Hadoop, you can go directly to the official website [https://seatunnel.apache.org/](https://seatunnel.apache.org/)\\n\\n-- Power by [InterestingLab](https://github.com/InterestingLab)"},{"id":"spark-execute-elasticsearch","metadata":{"permalink":"/blog/spark-execute-elasticsearch","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2021-12-30-spark-execute-elasticsearch.md","source":"@site/blog/2021-12-30-spark-execute-elasticsearch.md","title":"How to quickly write data to Elasticsearch using Spark","description":"When it comes to writing data to Elasticsearch, the first thing that comes to mind must be Logstash. Logstash is accepted by the majority of users because of its simplicity, scalability, and scalability. However, the ruler is shorter and the inch is longer, and Logstash must have application scenarios that it cannot apply to, such as:","date":"2021-12-30T00:00:00.000Z","formattedDate":"December 30, 2021","tags":[{"label":"Spark","permalink":"/blog/tags/spark"},{"label":"Kafka","permalink":"/blog/tags/kafka"},{"label":"Elasticsearch","permalink":"/blog/tags/elasticsearch"}],"readingTime":5.725,"truncated":false,"authors":[],"frontMatter":{"slug":"spark-execute-elasticsearch","title":"How to quickly write data to Elasticsearch using Spark","tags":["Spark","Kafka","Elasticsearch"]},"prevItem":{"title":"How to quickly import data from Hive into ClickHouse","permalink":"/blog/hive-to-clickhouse"},"nextItem":{"title":"How to use Spark to do OLAP analysis on TiDB","permalink":"/blog/spark-execute-tidb"}},"content":"When it comes to writing data to Elasticsearch, the first thing that comes to mind must be Logstash. Logstash is accepted by the majority of users because of its simplicity, scalability, and scalability. However, the ruler is shorter and the inch is longer, and Logstash must have application scenarios that it cannot apply to, such as:\\n\\n* Massive data ETL\\n* Massive data aggregation\\n* Multi-source data processing\\n\\nIn order to meet these scenarios, many students will choose Spark, use Spark operators to process data, and finally write the processing results to Elasticsearch.\\n\\nOur department used Spark to analyze Nginx logs, counted our web service access, aggregated Nginx logs every minute and finally wrote the results to Elasticsearch, and then used Kibana to configure real-time monitoring of the Dashboard. Both Elasticsearch and Kibana are convenient and practical, but with more and more similar requirements, how to quickly write data to Elasticsearch through Spark has become a big problem for us.\\n\\nToday, I would like to recommend a black technology Seatunnel [https://github.com/apache/incubator-seatunnel](https://github.com/apache/incubator-seatunnel) that can realize fast data writing. It is very easy to use , a high-performance, real-time data processing product that can deal with massive data. It is built on Spark and is easy to use, flexibly configured, and requires no development.\\n\\n![](/doc/image_zh/wd-struct.png)\\n\\n\\n## Kafka to Elasticsearch\\n\\nLike Logstash, Seatunnel also supports multiple types of data input. Here we take the most common Kakfa as the input source as an example to explain how to use Seatunnel to quickly write data to Elasticsearch\\n\\n### Log Sample\\n\\nThe original log format is as follows:\\n```\\n127.0.0.1 elasticsearch.cn 114.250.140.241 0.001s \\"127.0.0.1:80\\" [26/Oct/2018:21:54:32 +0800] \\"GET /article HTTP/1.1\\" 200 123 \\"-\\" - \\"Dalvik/2.1.0 (Linux; U; Android 7.1.1; OPPO R11 Build/NMF26X)\\"\\n```\\n\\n### Elasticsearch Document\\n\\nWe want to count the visits of each domain name in one minute. The aggregated data has the following fields:\\n```\\ndomain String\\nhostname String\\nstatus int\\ndatetime String\\ncount int\\n```\\n\\n## Seatunnel with Elasticsearch\\n\\nNext, I will introduce you in detail, how we read the data in Kafka through Seatunnel, parse and aggregate the data, and finally write the processing results into Elasticsearch.\\n\\n### Seatunnel\\n\\n[Seatunnel](https://github.com/apache/incubator-seatunnel) also has a very rich plug-in that supports reading data from Kafka, HDFS, Hive, performing various data processing, and converting the results Write to Elasticsearch, Kudu or Kafka.\\n\\n### Prerequisites\\n\\nFirst of all, we need to install seatunnel, the installation is very simple, no need to configure system environment variables\\n1. Prepare the Spark environment\\n2. Install Seatunnel\\n3. Configure Seatunnel\\n\\nThe following are simple steps, the specific installation can refer to [Quick Start](/docs/quick-start)\\n\\n```yaml\\ncd /usr/local\\nwget https://archive.apache.org/dist/spark/spark-2.2.0/spark-2.2.0-bin-hadoop2.7.tgz\\ntar -xvf https://archive.apache.org/dist/spark/spark-2.2.0/spark-2.2.0-bin-hadoop2.7.tgz\\nwget https://github.com/InterestingLab/seatunnel/releases/download/v1.1.1/seatunnel-1.1.1.zip\\nunzip seatunnel-1.1.1.zip\\ncd seatunnel-1.1.1\\n\\nvim config/seatunnel-env.sh\\n# Specify the Spark installation path\\nSPARK_HOME=${SPARK_HOME:-/usr/local/spark-2.2.0-bin-hadoop2.7}\\n```\\n\\n### Seatunnel Pipeline\\n\\nLike Logstash, we only need to write a configuration file of Seatunnel Pipeline to complete the data import. I believe that friends who know Logstash can start Seatunnel configuration soon.\\n\\nThe configuration file includes four parts, namely Spark, Input, filter and Output.\\n\\n#### Spark\\n\\n\\nThis part is the related configuration of Spark, which mainly configures the resource size required for Spark execution.\\n```\\nspark {\\n  spark.app.name = \\"seatunnel\\"\\n  spark.executor.instances = 2\\n  spark.executor.cores = 1\\n  spark.executor.memory = \\"1g\\"\\n  spark.streaming.batchDuration = 5\\n}\\n```\\n\\n#### Input\\n\\nThis part defines the data source. The following is a configuration example of reading data from Kafka,\\n\\n```\\nkafkaStream {\\n    topics = \\"seatunnel-es\\"\\n    consumer.bootstrap.servers = \\"localhost:9092\\"\\n    consumer.group.id = \\"seatunnel_es_group\\"\\n    consumer.rebalance.max.retries = 100\\n}\\n```\\n\\n#### Filter\\n\\nIn the Filter section, here we configure a series of conversions, including regular parsing to split logs, time conversion to convert HTTPDATE to a date format supported by Elasticsearch, type conversion for fields of type Number, and data aggregation through SQL\\n```yaml\\nfilter {\\n    # Parse the original log using regex\\n    # The initial data is in the raw_message field\\n    grok {\\n        source_field = \\"raw_message\\"\\n        pattern = \'%{NOTSPACE:hostname}\\\\\\\\s%{NOTSPACE:domain}\\\\\\\\s%{IP:remote_addr}\\\\\\\\s%{NUMBER:request_time}s\\\\\\\\s\\\\\\"%{DATA:upstream_ip}\\\\\\"\\\\\\\\s\\\\\\\\[%{HTTPDATE:timestamp}\\\\\\\\]\\\\\\\\s\\\\\\"%{NOTSPACE:method}\\\\\\\\s%{DATA:url}\\\\\\\\s%{NOTSPACE:http_ver}\\\\\\"\\\\\\\\s%{NUMBER:status}\\\\\\\\s%{NUMBER:body_bytes_send}\\\\\\\\s%{DATA:referer}\\\\\\\\s%{NOTSPACE:cookie_info}\\\\\\\\s\\\\\\"%{DATA:user_agent}\'\\n   }\\n    # Convert data in \\"dd/MMM/yyyy:HH:mm:ss Z\\" format to\\n    # format supported in Elasticsearch\\n    date {\\n        source_field = \\"timestamp\\"\\n        target_field = \\"datetime\\"\\n        source_time_format = \\"dd/MMM/yyyy:HH:mm:ss Z\\"\\n        target_time_format = \\"yyyy-MM-dd\'T\'HH:mm:ss.SSS+08:00\\"\\n    }\\n    ## Aggregate data with SQL\\n    sql {\\n        table_name = \\"access_log\\"\\n        sql = \\"select domain, hostname, int(status), datetime, count(*) from access_log group by domain, hostname, status, datetime\\"\\n    }\\n }\\n```\\n\\n#### Output\\nFinally, we write the processed structured data to Elasticsearch.\\n\\n```yaml\\noutput {\\n    elasticsearch {\\n        hosts = [\\"localhost:9200\\"]\\n        index = \\"seatunnel-${now}\\"\\n        es.batch.size.entries = 100000\\n        index_time_format = \\"yyyy.MM.dd\\"\\n    }\\n}\\n```\\n\\n### Running Seatunnel\\n\\nWe combine the above four-part configuration into our configuration file `config/batch.conf`.\\n\\n    vim config/batch.conf\\n\\n```\\nspark {\\n  spark.app.name = \\"seatunnel\\"\\n  spark.executor.instances = 2\\n  spark.executor.cores = 1\\n  spark.executor.memory = \\"1g\\"\\n  spark.streaming.batchDuration = 5\\n}\\ninput {\\n    kafkaStream {\\n        topics = \\"seatunnel-es\\"\\n        consumer.bootstrap.servers = \\"localhost:9092\\"\\n        consumer.group.id = \\"seatunnel_es_group\\"\\n        consumer.rebalance.max.retries = 100\\n    }\\n}\\nfilter {\\n    # Parse the original log using regex\\n    # The initial data is in the raw_message field\\n    grok {\\n        source_field = \\"raw_message\\"\\n        pattern = \'%{IP:hostname}\\\\\\\\s%{NOTSPACE:domain}\\\\\\\\s%{IP:remote_addr}\\\\\\\\s%{NUMBER:request_time}s\\\\\\\\s\\\\\\"%{DATA:upstream_ip}\\\\\\"\\\\\\\\s\\\\\\\\[%{HTTPDATE:timestamp}\\\\\\\\]\\\\\\\\s\\\\\\"%{NOTSPACE:method}\\\\\\\\s%{DATA:url}\\\\\\\\s%{NOTSPACE:http_ver}\\\\\\"\\\\\\\\s%{NUMBER:status}\\\\\\\\s%{NUMBER:body_bytes_send}\\\\\\\\s%{DATA:referer}\\\\\\\\s%{NOTSPACE:cookie_info}\\\\\\\\s\\\\\\"%{DATA:user_agent}\'\\n   }\\n    # Convert data in \\"dd/MMM/yyyy:HH:mm:ss Z\\" format to\\n    # format supported in Elasticsearch\\n    date {\\n        source_field = \\"timestamp\\"\\n        target_field = \\"datetime\\"\\n        source_time_format = \\"dd/MMM/yyyy:HH:mm:ss Z\\"\\n        target_time_format = \\"yyyy-MM-dd\'T\'HH:mm:00.SSS+08:00\\"\\n    }\\n    ## Aggregate data with SQL\\n    sql {\\n        table_name = \\"access_log\\"\\n        sql = \\"select domain, hostname, status, datetime, count(*) from access_log group by domain, hostname, status, datetime\\"\\n    }\\n }\\noutput {\\n    elasticsearch {\\n        hosts = [\\"localhost:9200\\"]\\n        index = \\"seatunnel-${now}\\"\\n        es.batch.size.entries = 100000\\n        index_time_format = \\"yyyy.MM.dd\\"\\n    }\\n}\\n```\\n\\nExecute the command, specify the configuration file, and run Seatunnel to write data to Elasticsearch. Here we take the local mode as an example.\\n\\n    ./bin/start-seatunnel.sh --config config/batch.conf -e client -m \'local[2]\'\\n\\nFinally, the data written into Elasticsearch is as follows, and with Kibana, real-time monitoring of web services can be realized ^_^.\\n\\n```\\n\\"_source\\": {\\n    \\"domain\\": \\"elasticsearch.cn\\",\\n    \\"hostname\\": \\"localhost\\",\\n    \\"status\\": \\"200\\",\\n    \\"datetime\\": \\"2018-11-26T21:54:00.000+08:00\\",\\n    \\"count\\": 26\\n  }\\n```\\n\\n## Conclusion\\n\\nIn this post, we introduced how to write data from Kafka to Elasticsearch via Seatunnel. You can quickly run a Spark Application with only one configuration file, complete data processing and writing, and do not need to write any code, which is very simple.\\n\\nWhen there are scenarios that Logstash cannot support or the performance of Logstah cannot meet expectations during data processing, you can try to use Seatunnel to solve the problem.\\n\\nIf you want to know more functions and cases of using Seatunnel in combination with Elasticsearch, Kafka and Hadoop, you can go directly to the official website [https://seatunnel.apache.org/](https://seatunnel.apache.org/)\\n\\n\\n**We will publish another article \\"How to Use Spark and Elasticsearch for Interactive Data Analysis\\" in the near future, so stay tuned.**\\n\\n## Contract us\\n* Mailing list : **dev@seatunnel.apache.org**. Send anything to `dev-subscribe@seatunnel.apache.org` and subscribe to the mailing list according to the replies.\\n* Slack: Send a `Request to join SeaTunnel slack` email to the mailing list (`dev@seatunnel.apache.org`), and we will invite you to join (please make sure you are registered with Slack before doing so).\\n* [bilibili B station video](https://space.bilibili.com/1542095008)"},{"id":"spark-execute-tidb","metadata":{"permalink":"/blog/spark-execute-tidb","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2021-12-30-spark-execute-tidb.md","source":"@site/blog/2021-12-30-spark-execute-tidb.md","title":"How to use Spark to do OLAP analysis on TiDB","description":"TiDB is a fusion database product targeting online transaction processing/online analytical processing. Distributed transactions, real-time OLAP and other important features.","date":"2021-12-30T00:00:00.000Z","formattedDate":"December 30, 2021","tags":[{"label":"Spark","permalink":"/blog/tags/spark"},{"label":"TiDB","permalink":"/blog/tags/ti-db"}],"readingTime":6.705,"truncated":false,"authors":[],"frontMatter":{"slug":"spark-execute-tidb","title":"How to use Spark to do OLAP analysis on TiDB","tags":["Spark","TiDB"]},"prevItem":{"title":"How to quickly write data to Elasticsearch using Spark","permalink":"/blog/spark-execute-elasticsearch"},"nextItem":{"title":"How to support Spark StructuredStreaming","permalink":"/blog/spark-structured-streaming"}},"content":"![](https://download.pingcap.com/images/tidb-planet.jpg)\\n\\n[TiDB](https://github.com/pingcap/tidb) is a fusion database product targeting online transaction processing/online analytical processing. Distributed transactions, real-time OLAP and other important features.\\n\\nTiSpark is a product launched by PingCAP to solve the complex OLAP needs of users. It uses the Spark platform and integrates the advantages of TiKV distributed clusters.\\n\\nCompleting OLAP operations with TiSpark directly requires knowledge of Spark and some development work. So, are there some out-of-the-box tools that can help us use TiSpark to complete OLAP analysis on TiDB more quickly?\\n\\nAt present, there is a tool **Seatunnel** in the open source community, the project address [https://github.com/apache/incubator-seatunnel](https://github.com/apache/incubator-seatunnel), which can be based on Spark, Quickly implement TiDB data reading and OLAP analysis based on TiSpark.\\n\\n\\n## Operating TiDB with Seatunnel\\n\\nWe have such a requirement online. Read the website access data of a certain day from TiDB, count the number of visits of each domain name and the status code returned by the service, and finally write the statistical results to another table in TiDB. Let\'s see how Seatunnel implements such a function.\\n\\n### Seatunnel\\n\\n[Seatunnel](https://github.com/apache/incubator-seatunnel) is a very easy-to-use, high-performance, real-time data processing product that can deal with massive data. It is built on Spark. Seatunnel has a very rich set of plugins that support reading data from TiDB, Kafka, HDFS, Kudu, perform various data processing, and then write the results to TiDB, ClickHouse, Elasticsearch or Kafka.\\n\\n\\n#### Ready to work\\n\\n##### 1. Introduction to TiDB table structure\\n\\n**Input** (table where access logs are stored)\\n\\n```\\nCREATE TABLE access_log (\\n    domain VARCHAR(255),\\n    datetime VARCHAR(63),\\n    remote_addr VARCHAR(63),\\n    http_ver VARCHAR(15),\\n    body_bytes_send INT,\\n    status INT,\\n    request_time FLOAT,\\n    url TEXT\\n)\\n```\\n\\n```\\n+-----------------+--------------+------+------+---------+-------+\\n| Field           | Type         | Null | Key  | Default | Extra |\\n+-----------------+--------------+------+------+---------+-------+\\n| domain          | varchar(255) | YES  |      | NULL    |       |\\n| datetime        | varchar(63)  | YES  |      | NULL    |       |\\n| remote_addr     | varchar(63)  | YES  |      | NULL    |       |\\n| http_ver        | varchar(15)  | YES  |      | NULL    |       |\\n| body_bytes_send | int(11)      | YES  |      | NULL    |       |\\n| status          | int(11)      | YES  |      | NULL    |       |\\n| request_time    | float        | YES  |      | NULL    |       |\\n| url             | text         | YES  |      | NULL    |       |\\n+-----------------+--------------+------+------+---------+-------+\\n```\\n\\n**Output** (table where result data is stored)\\n\\n```\\nCREATE TABLE access_collect (\\n    date VARCHAR(23),\\n    domain VARCHAR(63),\\n    status INT,\\n    hit INT\\n)\\n```\\n\\n```\\n+--------+-------------+------+------+---------+-------+\\n| Field  | Type        | Null | Key  | Default | Extra |\\n+--------+-------------+------+------+---------+-------+\\n| date   | varchar(23) | YES  |      | NULL    |       |\\n| domain | varchar(63) | YES  |      | NULL    |       |\\n| status | int(11)     | YES  |      | NULL    |       |\\n| hit    | int(11)     | YES  |      | NULL    |       |\\n+--------+-------------+------+------+---------+-------+\\n```\\n\\n##### 2. Install Seatunnel\\n\\nAfter we have the input and output tables of TiDB, we need to install Seatunnel. The installation is very simple, and there is no need to configure system environment variables\\n1. Prepare the Spark environment\\n2. Install Seatunnel\\n3. Configure Seatunnel\\n\\nThe following are simple steps, the specific installation can refer to [Quick Start](/docs/quick-start)\\n\\n```\\n# Download and install Spark\\ncd /usr/local\\nwget https://archive.apache.org/dist/spark/spark-2.1.0/spark-2.1.0-bin-hadoop2.7.tgz\\ntar -xvf https://archive.apache.org/dist/spark/spark-2.1.0/spark-2.1.0-bin-hadoop2.7.tgz\\nwget\\n# Download and install seatunnel\\nhttps://github.com/InterestingLab/seatunnel/releases/download/v1.2.0/seatunnel-1.2.0.zip\\nunzip seatunnel-1.2.0.zip\\ncd seatunnel-1.2.0\\n\\nvim config/seatunnel-env.sh\\n# Specify the Spark installation path\\nSPARK_HOME=${SPARK_HOME:-/usr/local/spark-2.1.0-bin-hadoop2.7}\\n```\\n\\n\\n### Implement the Seatunnel processing flow\\n\\nWe only need to write a Seatunnel configuration file to read, process, and write data.\\n\\nThe Seatunnel configuration file consists of four parts, `Spark`, `Input`, `Filter` and `Output`. The `Input` part is used to specify the input source of the data, the `Filter` part is used to define various data processing and aggregation, and the `Output` part is responsible for writing the processed data to the specified database or message queue.\\n\\nThe whole processing flow is `Input` -> `Filter` -> `Output`, which constitutes the processing flow (Pipeline) of Seatunnel.\\n\\n> The following is a specific configuration, which is derived from an online practical application, but simplified for demonstration.\\n\\n\\n##### Input (TiDB)\\n\\nThis part of the configuration defines the input source. The following is to read data from a table in TiDB.\\n\\n    input {\\n        tidb {\\n            database = \\"nginx\\"\\n            pre_sql = \\"select * from nginx.access_log\\"\\n            table_name = \\"spark_nginx_input\\"\\n        }\\n    }\\n\\n##### Filter\\n\\nIn the Filter section, here we configure a series of transformations, most of the data analysis requirements are completed in the Filter. Seatunnel provides a wealth of plug-ins enough to meet various data analysis needs. Here we complete the data aggregation operation through the SQL plugin.\\n\\n    filter {\\n        sql {\\n            table_name = \\"spark_nginx_log\\"\\n            sql = \\"select count(*) as hit, domain, status, substring(datetime, 1, 10) as date from spark_nginx_log where substring(datetime, 1, 10)=\'2019-01-20\' group by domain, status, substring(datetime, 1, 10)\\"\\n        }\\n    }\\n\\n\\n##### Output (TiDB)\\n\\nFinally, we write the processed results to another table in TiDB. TiDB Output is implemented through JDBC\\n\\n    output {\\n        tidb {\\n            url = \\"jdbc:mysql://127.0.0.1:4000/nginx?useUnicode=true&characterEncoding=utf8\\"\\n            table = \\"access_collect\\"\\n            user = \\"username\\"\\n            password = \\"password\\"\\n            save_mode = \\"append\\"\\n        }\\n    }\\n\\n##### Spark\\n\\nThis part is related to Spark configuration. It mainly configures the resource size required for Spark execution and other Spark configurations.\\n\\nOur TiDB Input plugin is implemented based on TiSpark, which relies on TiKV cluster and Placement Driver (PD). So we need to specify PD node information and TiSpark related configuration `spark.tispark.pd.addresses` and `spark.sql.extensions`.\\n\\n    spark {\\n      spark.app.name = \\"seatunnel-tidb\\"\\n      spark.executor.instances = 2\\n      spark.executor.cores = 1\\n      spark.executor.memory = \\"1g\\"\\n      # Set for TiSpark\\n      spark.tispark.pd.addresses = \\"localhost:2379\\"\\n      spark.sql.extensions = \\"org.apache.spark.sql.TiExtensions\\"\\n    }\\n\\n\\n#### Run Seatunnel\\n\\nWe combine the above four parts into our final configuration file `conf/tidb.conf`\\n\\n```\\nspark {\\n    spark.app.name = \\"seatunnel-tidb\\"\\n    spark.executor.instances = 2\\n    spark.executor.cores = 1\\n    spark.executor.memory = \\"1g\\"\\n    # Set for TiSpark\\n    spark.tispark.pd.addresses = \\"localhost:2379\\"\\n    spark.sql.extensions = \\"org.apache.spark.sql.TiExtensions\\"\\n}\\ninput {\\n    tidb {\\n        database = \\"nginx\\"\\n        pre_sql = \\"select * from nginx.access_log\\"\\n        table_name = \\"spark_table\\"\\n    }\\n}\\nfilter {\\n    sql {\\n        table_name = \\"spark_nginx_log\\"\\n        sql = \\"select count(*) as hit, domain, status, substring(datetime, 1, 10) as date from spark_nginx_log where substring(datetime, 1, 10)=\'2019-01-20\' group by domain, status, substring(datetime, 1, 10)\\"\\n    }\\n}\\noutput {\\n    tidb {\\n        url = \\"jdbc:mysql://127.0.0.1:4000/nginx?useUnicode=true&characterEncoding=utf8\\"\\n        table = \\"access_collect\\"\\n        user = \\"username\\"\\n        password = \\"password\\"\\n        save_mode = \\"append\\"\\n    }\\n}\\n```\\n\\nExecute the command, specify the configuration file, and run Seatunnel to implement our data processing logic.\\n\\n* Local\\n\\n> ./bin/start-seatunnel.sh --config config/tidb.conf --deploy-mode client --master \'local[2]\'\\n\\n* yarn-client\\n\\n> ./bin/start-seatunnel.sh --config config/tidb.conf --deploy-mode client --master yarn\\n\\n* yarn-cluster\\n\\n> ./bin/start-seatunnel.sh --config config/tidb.conf --deploy-mode cluster -master yarn\\n\\nIf it is a local test and verification logic, you can use the local mode (Local). Generally, in the production environment, the `yarn-client` or `yarn-cluster` mode is used.\\n\\n#### test result\\n\\n```\\nmysql> select * from access_collect;\\n+------------+--------+--------+------+\\n| date       | domain | status | hit  |\\n+------------+--------+--------+------+\\n| 2019-01-20 | b.com  |    200 |   63 |\\n| 2019-01-20 | a.com  |    200 |   85 |\\n+------------+--------+--------+------+\\n2 rows in set (0.21 sec)\\n```\\n\\n\\n\\n## Conclusion\\n\\nIn this article, we introduced how to use Seatunnel to read data from TiDB, do simple data processing and write it to another table in TiDB. Data can be imported quickly with only one configuration file without writing any code.\\n\\nIn addition to supporting TiDB data sources, Seatunnel also supports Elasticsearch, Kafka, Kudu, ClickHouse and other data sources.\\n\\n**At the same time, we are developing an important function, which is to use the transaction features of TiDB in Seatunnel to realize streaming data processing from Kafka to TiDB, and support Exactly-Once data from end (Kafka) to end (TiDB). consistency. **\\n\\nIf you want to know more functions and cases of Seatunnel combined with TiDB, ClickHouse, Elasticsearch and Kafka, you can go directly to the official website [https://seatunnel.apache.org/](https://seatunnel.apache.org/)\\n\\n## Contract us\\n* Mailing list : **dev@seatunnel.apache.org**. Send anything to `dev-subscribe@seatunnel.apache.org` and subscribe to the mailing list according to the replies.\\n* Slack: Send a `Request to join SeaTunnel slack` email to the mailing list (`dev@seatunnel.apache.org`), and we will invite you to join (please make sure you are registered with Slack before doing so).\\n* [bilibili B station video](https://space.bilibili.com/1542095008)\\n\\n-- Power by [InterestingLab](https://github.com/InterestingLab)"},{"id":"spark-structured-streaming","metadata":{"permalink":"/blog/spark-structured-streaming","editUrl":"https://github.com/apache/incubator-seatunnel-website/edit/main/blog/2021-12-30-spark-structured-streaming.md","source":"@site/blog/2021-12-30-spark-structured-streaming.md","title":"How to support Spark StructuredStreaming","description":"Foreword","date":"2021-12-30T00:00:00.000Z","formattedDate":"December 30, 2021","tags":[{"label":"Spark","permalink":"/blog/tags/spark"},{"label":"StructuredStreaming","permalink":"/blog/tags/structured-streaming"}],"readingTime":7.8,"truncated":false,"authors":[],"frontMatter":{"slug":"spark-structured-streaming","title":"How to support Spark StructuredStreaming","tags":["Spark","StructuredStreaming"]},"prevItem":{"title":"How to use Spark to do OLAP analysis on TiDB","permalink":"/blog/spark-execute-tidb"}},"content":"### Foreword\\n\\nStructuredStreaming is a newly opened module after Spark 2.0. Compared with SparkStreaming, it has some prominent advantages:<br/> &emsp;&emsp;First, it can achieve lower latency;<br/>\\n&emsp;&emsp;Second, real-time aggregation can be done, such as real-time calculation of the total sales of each commodity every day;<br/>\\n&emsp;&emsp;Third, you can do the association between streams, for example, to calculate the click rate of an advertisement, you need to associate the exposure record of the advertisement with the click record. <br/>\\nThe above points may be cumbersome or difficult to implement if using SparkStreaming, but it will be easier to implement using StructuredStreaming.\\n### How to use StructuredStreaming\\nMaybe you have not studied StructuredStreaming in detail, but found that StructuredStreaming can solve your needs very well. How to quickly use StructuredStreaming to solve your needs? Currently there is a tool **Seatunnel** in the community, the project address: [https://github.com/apache/incubator-seatunnel](https://github.com/apache/incubator-seatunnel) ,\\nIt can help you use StructuredStreaming to complete your needs efficiently and at low cost.\\n\\n### Seatunnel\\n\\nSeatunnel is a very easy-to-use, high-performance, real-time data processing product that can deal with massive data. It is built on Spark. Seatunnel has a very rich set of plug-ins, supports reading data from Kafka, HDFS, Kudu, performs various data processing, and writes the results to ClickHouse, Elasticsearch or Kafka\\n\\n### Ready to work\\n\\nFirst we need to install Seatunnel, the installation is very simple, no need to configure system environment variables\\n\\n1. Prepare the Spark environment\\n2. Install Seatunnel\\n3. Configure Seatunnel\\n\\nThe following are simple steps, the specific installation can refer to [Quick Start](/docs/quick-start)\\n\\n```\\ncd /usr/local\\nwget https://archive.apache.org/dist/spark/spark-2.2.0/spark-2.2.0-bin-hadoop2.7.tgz\\ntar -xvf https://archive.apache.org/dist/spark/spark-2.2.0/spark-2.2.0-bin-hadoop2.7.tgz\\nwget https://github.com/InterestingLab/seatunnel/releases/download/v1.3.0/seatunnel-1.3.0.zip\\nunzip seatunnel-1.3.0.zip\\ncd seatunnel-1.3.0\\n\\nvim config/seatunnel-env.sh\\n# Specify the Spark installation path\\nSPARK_HOME=${SPARK_HOME:-/usr/local/spark-2.2.0-bin-hadoop2.7}\\n```\\n\\n### Seatunnel Pipeline\\n\\nWe only need to write a configuration file of Seatunnel Pipeline to complete the data import.\\n\\nThe configuration file includes four parts, namely Spark, Input, filter and Output.\\n\\n#### Spark\\n\\nThis part is the related configuration of Spark, which mainly configures the resource size required for Spark execution.\\n\\n```\\nspark {\\n  spark.app.name = \\"seatunnel\\"\\n  spark.executor.instances = 2\\n  spark.executor.cores = 1\\n  spark.executor.memory = \\"1g\\"\\n}\\n```\\n\\n#### Input\\n\\nBelow is an example of reading data from kafka\\n\\n```\\nkafkaStream {\\n    topics = \\"seatunnel\\"\\n    consumer.bootstrap.servers = \\"localhost:9092\\"\\n    schema = \\"{\\\\\\"name\\\\\\":\\\\\\"string\\\\\\",\\\\\\"age\\\\\\":\\\\\\"integer\\\\\\",\\\\\\"addrs\\\\\\":{\\\\\\"country\\\\\\":\\\\\\"string\\\\\\",\\\\\\"city\\\\\\":\\\\\\"string\\\\\\"}}\\"\\n}\\n```\\n\\nThrough the above configuration, the data in kafka can be read. Topics is the topic of kafka to be subscribed to. Subscribing to multiple topics at the same time can be separated by commas. Consumer.bootstrap.servers is the list of Kafka servers, and schema is optional. Because the value read by StructuredStreaming from kafka (official fixed field value) is of binary type, see http://spark.apache.org/docs/latest/structured-streaming-kafka-integration.html\\nBut if you are sure that the data in your kafka is a json string, you can specify the schema, and the input plugin will parse it according to the schema you specify\\n\\n#### Filter\\n\\nHere is a simple filter example\\n\\n```\\nfilter{\\n    sql{\\n        table_name = \\"student\\"\\n        sql = \\"select name,age from student\\"\\n    }\\n}\\n```\\n`table_name` is the registered temporary table name for easy use in the following sql\\n\\n#### Output\\n\\nThe processed data is output, assuming that our output is also kafka\\n\\n```\\noutput{\\n    kafka {\\n        topic = \\"seatunnel\\"\\n        producer.bootstrap.servers = \\"localhost:9092\\"\\n        streaming_output_mode = \\"update\\"\\n        checkpointLocation = \\"/your/path\\"\\n    }\\n}\\n```\\n\\n`topic` is the topic you want to output, `producer.bootstrap.servers` is a list of kafka clusters, `streaming_output_mode` is an output mode parameter of StructuredStreaming, there are three types of `append|update|complete`, for details, see the documentation http: //spark.apache.org/docs/latest/structured-streaming-programming-guide.html#output-modes\\n\\n`checkpointLocation` is the checkpoint path of StructuredStreaming. If configured, this directory will store the running information of the program. For example, if the program exits and restarts, it will continue to consume the last offset.\\n\\n### Scenario Analysis\\n\\nThe above is a simple example. Next, we will introduce a slightly more complex business scenario.\\n\\n#### Scenario 1: Real-time aggregation scenario\\n\\nSuppose there is now a mall with 10 kinds of products on it, and now it is necessary to find the daily sales of each product in real time, and even to find the number of buyers of each product (not very precise).\\nThe huge advantage of this is that massive data can be aggregated during real-time processing, and there is no need to write data into the data warehouse first, and then run offline scheduled tasks for aggregation.\\nIt is still very convenient to operate.\\n\\nThe data of kafka is as follows\\n\\n```\\n{\\"good_id\\":\\"abc\\",\\"price\\":300,\\"user_id\\":123456,\\"time\\":1553216320}\\n```\\n\\nSo how do we use Seatunnel to fulfill this requirement, of course, we only need to configure it.\\n\\n```\\n#The configuration in spark is configured according to business requirements\\nspark {\\n  spark.app.name = \\"seatunnel\\"\\n  spark.executor.instances = 2\\n  spark.executor.cores = 1\\n  spark.executor.memory = \\"1g\\"\\n}\\n\\n#configure input\\ninput {\\n    kafkaStream {\\n        topics = \\"good_topic\\"\\n        consumer.bootstrap.servers = \\"localhost:9092\\"\\n        schema = \\"{\\\\\\"good_id\\\\\\":\\\\\\"string\\\\\\",\\\\\\"price\\\\\\":\\\\\\"integer\\\\\\",\\\\\\"user_id\\\\\\":\\\\\\"Long\\\\\\",\\\\\\"time\\\\\\":\\\\\\"Long\\\\\\"}\\"\\n    }\\n}\\n\\n#configure filter    \\nfilter {\\n    \\n    #When the program is doing aggregation, it will internally store the aggregation state of the program since startup, which will lead to OOM over time. If the watermark is set, the program will automatically clean up the state other than the watermark.\\n    #Here means use the ts field to set the watermark, the limit is 1 day\\n\\n    Watermark {\\n        time_field = \\"time\\"\\n        time_type = \\"UNIX\\"              #UNIX represents a timestamp with a time field of 10, and other types can be found in the plugin documentation for details.\\n        time_pattern = \\"yyyy-MM-dd\\"     #The reason why the ts is assigned to the day is because the daily sales are sought, if the hourly sales are sought, the hour can be assigned `yyyy-MM-dd HH`\\n        delay_threshold = \\"1 day\\"\\n        watermark_field = \\"ts\\"          #After setting the watermark, a new field will be added, `ts` is the name of this field\\n    }\\n    \\n    #The reason for group by ts is to make the watermark take effect, approx_count_distinct is an estimate, not an exact count_distinct\\n    sql {\\n        table_name = \\"good_table_2\\"\\n        sql = \\"select good_id,sum(price) total,\\tapprox_count_distinct(user_id) person from good_table_2 group by ts,good_id\\"\\n    }\\n}\\n\\n#Next we choose to output the results to Kafka in real time\\noutput{\\n    kafka {\\n        topic = \\"seatunnel\\"\\n        producer.bootstrap.servers = \\"localhost:9092\\"\\n        streaming_output_mode = \\"update\\"\\n        checkpointLocation = \\"/your/path\\"\\n    }\\n}\\n\\n```\\nThe above configuration is complete, start Seatunnel, and you can get the results you want.\\n\\n#### Scenario 2: Multiple stream association scenarios\\n\\nSuppose you have placed an advertisement on a certain platform, and now you need to calculate the CTR (click-through rate) of each advertisement in real time. The data comes from two topics, one is the advertisement exposure log, and the other is the advertisement click log.\\nAt this point, we need to associate the two stream data together for calculation, and Seatunnel also supports this function recently, let\'s take a look at how to do it:\\n\\n\\nClick on topic data format\\n\\n```\\n{\\"ad_id\\":\\"abc\\",\\"click_time\\":1553216320,\\"user_id\\":12345}\\n\\n```\\n\\nExposure topic data format\\n\\n```\\n{\\"ad_id\\":\\"abc\\",\\"show_time\\":1553216220,\\"user_id\\":12345}\\n\\n```\\n\\n```\\n#The configuration in spark is configured according to business requirements\\nspark {\\n  spark.app.name = \\"seatunnel\\"\\n  spark.executor.instances = 2\\n  spark.executor.cores = 1\\n  spark.executor.memory = \\"1g\\"\\n}\\n\\n#configure input\\ninput {\\n    \\n    kafkaStream {\\n        topics = \\"click_topic\\"\\n        consumer.bootstrap.servers = \\"localhost:9092\\"\\n        schema = \\"{\\\\\\"ad_id\\\\\\":\\\\\\"string\\\\\\",\\\\\\"user_id\\\\\\":\\\\\\"Long\\\\\\",\\\\\\"click_time\\\\\\":\\\\\\"Long\\\\\\"}\\"\\n        table_name = \\"click_table\\"\\n    }\\n    \\n    kafkaStream {\\n        topics = \\"show_topic\\"\\n        consumer.bootstrap.servers = \\"localhost:9092\\"\\n        schema = \\"{\\\\\\"ad_id\\\\\\":\\\\\\"string\\\\\\",\\\\\\"user_id\\\\\\":\\\\\\"Long\\\\\\",\\\\\\"show_time\\\\\\":\\\\\\"Long\\\\\\"}\\"\\n        table_name = \\"show_table\\"\\n    }\\n}\\n\\nfilter {\\n    \\n    #Left association right table must set watermark\\n    #Right off left and right tables must set watermark\\n    #http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#inner-joins-with-optional-watermarking\\n    Watermark {\\n              source_table_name = \\"click_table\\" #Here you can specify to add a watermark to a temporary table. If you don\'t specify it, it will be the first one in the input.\\n              time_field = \\"time\\"\\n              time_type = \\"UNIX\\"               \\n              delay_threshold = \\"3 hours\\"\\n              watermark_field = \\"ts\\" \\n              result_table_name = \\"click_table_watermark\\" #After adding the watermark, it can be registered as a temporary table, which is convenient for subsequent use in sql\\n    }\\n    \\n    Watermark {\\n                source_table_name = \\"show_table\\" \\n                time_field = \\"time\\"\\n                time_type = \\"UNIX\\"               \\n                delay_threshold = \\"2 hours\\"\\n                watermark_field = \\"ts\\" \\n                result_table_name = \\"show_table_watermark\\" \\n     }\\n    \\n    \\n    sql {\\n        table_name = \\"show_table_watermark\\"\\n        sql = \\"select a.ad_id,count(b.user_id)/count(a.user_id) ctr from show_table_watermark as a left join click_table_watermark as b on a.ad_id = b.ad_id and a.user_id = b.user_id \\"\\n    }\\n    \\n}\\n\\n#Next we choose to output the results to Kafka in real time\\noutput {\\n    kafka {\\n        topic = \\"seatunnel\\"\\n        producer.bootstrap.servers = \\"localhost:9092\\"\\n        streaming_output_mode = \\"append\\" #Stream association only supports append mode\\n        checkpointLocation = \\"/your/path\\"\\n    }\\n}\\n```\\nThrough configuration, the case of stream association is also completed here.\\n\\n### Conclusion\\nThrough configuration, you can quickly use StructuredStreaming for real-time data processing, but you still need to understand some concepts of StructuredStreaming, such as the watermark mechanism, and the output mode of the program.\\n\\nFinally, Seatunnel also supports spark streaming and spark batching of course.\\nIf you are also interested in these two, you can read our previous article \\"[How to quickly import data from Hive into ClickHouse](2021-12-30-hive-to-clickhouse.md)\\",\\n\\"[Excellent data engineer, how to use Spark to do OLAP analysis on TiDB] (2021-12-30-spark-execute-tidb.md)\\",\\n\\"[How to use Spark to quickly write data to Elasticsearch] (2021-12-30-spark-execute-elasticsearch.md)\\"\\n\\nIf you want to know more functions and cases of Seatunnel combined with HBase, ClickHouse, Elasticsearch, Kafka, MySQL and other data sources, you can go directly to the official website [https://seatunnel.apache.org/](https://seatunnel.apache. org/)\\n\\n## \u8054\u7cfb\u6211\u4eec\\n* Mailing list : **dev@seatunnel.apache.org**. Send anything to `dev-subscribe@seatunnel.apache.org` and subscribe to the mailing list according to the replies.\\n* Slack: Send a `Request to join SeaTunnel slack` email to the mailing list (`dev@seatunnel.apache.org`), and we will invite you to join (please make sure you are registered with Slack before doing so).\\n* [bilibili B station video](https://space.bilibili.com/1542095008)"}]}')}}]);